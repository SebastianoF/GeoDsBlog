<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-02-09">

<title>Bearing’s mathematics – A Geospatial Data Science Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../images/favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-VPPV7D4HSQ"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-VPPV7D4HSQ', { 'anonymize_ip': true});
</script>
<style>html{ scroll-behavior: smooth; }</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta name="twitter:title" content="Bearing’s mathematics – A Geospatial Data Science Blog">
<meta name="twitter:description" content="Computing directions on the sphere and the ellipsoid">
<meta name="twitter:image" content="https://sebastianof.github.io/GeoDsBlog/posts/gds-2025-02-09-bearing/images/cover.png">
<meta name="twitter:image-height" content="713">
<meta name="twitter:image-width" content="1268">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">A Geospatial Data Science Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-posts" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Posts</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-posts">    
        <li>
    <a class="dropdown-item" href="../../posts/all.html">
 <span class="dropdown-text">All posts</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../posts/gds.html">
 <span class="dropdown-text">Geospatial Data Science</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../posts/bp.html">
 <span class="dropdown-text">Code development</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-about" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">About</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-about">    
        <li>
    <a class="dropdown-item" href="../../about/about.html">
 <span class="dropdown-text">Blog</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../about/feedback.html">
 <span class="dropdown-text">Feedback</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../about/licence.html">
 <span class="dropdown-text">Licence</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../about/CV_for_humans/curriculum.pdf">
 <span class="dropdown-text">CV for humans</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../about/CV_for_machines/curriculum.docx.pdf">
 <span class="dropdown-text">CV for machines</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/sebastianof/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:sebastiano.ferraris@gmail.com"> <i class="bi bi-envelope" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Bearing’s mathematics</h1>
            <p class="subtitle lead">Computing directions on the sphere and the ellipsoid</p>
                                <div class="quarto-categories">
                <div class="quarto-category">tutorial</div>
                <div class="quarto-category">geospatial</div>
                <div class="quarto-category">mathematics</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 9, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#sec-spherical-model" id="toc-sec-spherical-model" class="nav-link" data-scroll-target="#sec-spherical-model">Bearings for the Earth’s spherical model</a></li>
  <li><a href="#sec-ellipsoid-model" id="toc-sec-ellipsoid-model" class="nav-link" data-scroll-target="#sec-ellipsoid-model">Bearings for the Earth’s ellipsoid model</a>
  <ul class="collapse">
  <li><a href="#crossing-the-anti-meridian" id="toc-crossing-the-anti-meridian" class="nav-link" data-scroll-target="#crossing-the-anti-meridian">Crossing the anti-meridian</a></li>
  </ul></li>
  <li><a href="#sec-coding" id="toc-sec-coding" class="nav-link" data-scroll-target="#sec-coding">Python code</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><img src="images/cover.png" class="img-fluid"></p>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>This post is not about how to stand the part of physics where experiments are cheap<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>Today’s topic is the solution of a recurring problem in geospatial data science, that frequently arises when dealing with <a href="https://en.wikipedia.org/wiki/Automatic_identification_system">Automatic Identification System data</a>, and more in general when having to do with distances and angles on the surface of a sphere.</p>
<p>Considered along with the <a href="https://sebastianof.github.io/GeoDsBlog/posts/gds-2024-01-10-haversine-dist/">Haversine distance</a>, the <em>bearing</em> at the point <span class="math inline">\(A\)</span> in the direction of another point <span class="math inline">\(B\)</span> is the angle <span class="math inline">\(\beta\)</span> between the meridian passing through <span class="math inline">\(A\)</span> and the geodesic connecting <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>.</p>
<p>For maritime applications, the <em>bearing of a vessel</em> is the angle between the meridian and the direction where the vessel is intending to go, measured from zero to <span class="math inline">\(360\)</span> degrees clockwise.</p>
<p>It is not the same as the <em>heading</em>, that is the angle between the meridian and the actual vessel orientation; heading and bearing may or may not be coincident, depending on the navigation conditions such as water currents, winds and the consequent route adjustments.</p>
<p>In the first and second parts of this blog post you will find the mathematical derivation of the bearing formula for the sphere and the ellipsoid model respectively. If you are here for the python code, you can skip directly to the third part.</p>
<ul>
<li><a href="#sec-spherical-model" class="quarto-xref">Section&nbsp;2</a> Bearings for the Earth’s spherical model</li>
<li><a href="#sec-ellipsoid-model" class="quarto-xref">Section&nbsp;3</a> Bearings for the Earth’s ellipsoidal model</li>
<li><a href="#sec-coding" class="quarto-xref">Section&nbsp;4</a> Python code</li>
</ul>
</section>
<section id="sec-spherical-model" class="level2">
<h2 class="anchored" data-anchor-id="sec-spherical-model">Bearings for the Earth’s spherical model</h2>
<p>This is the notation we are using for latitude and longitude in degrees and radians:</p>
<p><span class="math display">\[
\begin{align*}
\theta &amp;:= \text{rad}(\text{Lon}) \\
\varphi &amp;:= \text{rad}(\text{Lat}) \\
\end{align*}
\]</span></p>
<p>To project a point <span class="math inline">\((\theta, \varphi)\)</span> with <span class="math inline">\(\theta \in [-\pi, \pi]\)</span> and <span class="math inline">\(\varphi \in [-\pi/2, \pi/2]\)</span>, on the sphere of radius <span class="math inline">\(R\)</span> we use the immersion:</p>
<p><span class="math display">\[
\iota: \mathbb{S}^2 \rightarrow  \mathbb{R}^3
\]</span></p>
<p><span class="math display">\[
\iota(\theta, \varphi) = \begin{cases}
       x = R \cos\varphi \cos\theta\\
       y = R \cos\varphi \sin\theta\\
       z = R \sin\varphi\\
     \end{cases}
\]</span></p>
<p>that is a spherical coordinate system with North pole corresponding to <span class="math inline">\(90\)</span> degrees latitude and the South pole to <span class="math inline">\(-90\)</span> degrees latitude, <a href="https://sebastianof.github.io/GeoDsBlog/posts/gds-2024-01-10-haversine-dist/#fig-spherical-coordinates">also presented in our previous post about the Haversine distance</a>.</p>
<div id="fig-bearing-definition" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-bearing-definition-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/figure_1_bearing_from_A_to_B.png" id="fig-bearing-definition" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-bearing-definition-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1
</figcaption>
</figure>
</div>
<p>Given two points on the sphere, a position <span class="math inline">\(A = (\theta_A, \varphi_A)\)</span> and a destination <span class="math inline">\(B = (\theta_B, \varphi_B)\)</span>, the bearing <span class="math inline">\(\beta\)</span> from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span> is the angle between</p>
<ul>
<li>the plane passing through <span class="math inline">\(A\)</span>, the north pole <span class="math inline">\(N\)</span> and the origin <span class="math inline">\(O\)</span>, indicated with <span class="math inline">\(\pi(OAN)\)</span>,</li>
<li>and the plane <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> and <span class="math inline">\(O\)</span>, indicated with <span class="math inline">\(\pi(OAB)\)</span>.</li>
</ul>
<p>The angle between two plane coincides with the angle between their two normals, that can be computed with the exterior products<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>:</p>
<p><span class="math display">\[
~\text{ Vector } \perp \text{ to } \pi(OAN) \text{ is } \hat{n}_N^A = \frac{N\times A}{ \left\Vert N\times A \right\Vert } \\
~ \\
~\text{ Vector } \perp \text{ to } \pi(OAB) \text{ is } \hat{n}_B^A = \frac{B\times A}{ \left\Vert B\times A \right\Vert }  \\
\]</span></p>
<p>Therefore the bearing is the angle between <span class="math inline">\(\hat{n}_N^A\)</span> and <span class="math inline">\(\hat{n}_B^A\)</span>, and can be computed leveraging on the scalar product definition:</p>
<p><span class="math display">\[
\hat{n}_B^A \cdot \hat{n}_N^A = \left\Vert \hat{n}_B^A \right\Vert  \left\Vert \hat{n}_N^A \right\Vert \cos \beta
\]</span></p>
<p>resulting in <span class="math inline">\(\cos(\beta) = \hat{n}_B^A \cdot \hat{n}_N^A\)</span>, as the vectors are already normalized.</p>
<p>At this point, inverting the cosine would give the answer.</p>
<p>But this not yet the end of the blog post. The cosine is invertible only between <span class="math inline">\(0\)</span> and <span class="math inline">\(\pi\)</span>, so we need some more digging, as the proposed solution would work only for the bearings pointing eastwards. An option to solve the problem and to finish here the blog post is to add a sign based on the cardinal direction.</p>
<div id="fig-after-rotataion" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-after-rotataion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/figure_2_after_rotation.png" id="fig-after-rotataion" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-after-rotataion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2
</figcaption>
</figure>
</div>
<p>There is a better strategy: starting with the observation that <span class="math inline">\(\beta\)</span> is invariant under the rotations around the <span class="math inline">\(z\)</span> axis, we can rotate the sphere to make <span class="math inline">\(\tilde{\theta}_A = 0\)</span> and <span class="math inline">\(\tilde{\theta}_B = \theta_B - \theta_A\)</span>. In this reference <span class="math inline">\(N \times A\)</span> is parallel to the <span class="math inline">\(y\)</span> axis, and <span class="math inline">\(\beta\)</span> becomes the angle between <span class="math inline">\(\hat{n}_B^A\)</span> and the <span class="math inline">\(y\)</span>-axis.</p>
<p>Moreover, the cosine of <span class="math inline">\(\beta\)</span> is the projection of <span class="math inline">\(\hat{n}_B^A\)</span> on the <span class="math inline">\(y\)</span> axis, which is its <span class="math inline">\(y\)</span>-component, and the sine of <span class="math inline">\(\beta\)</span> is the projection of <span class="math inline">\(\hat{n}_B^A\)</span> on the plane <span class="math inline">\(xz\)</span>, that is the square root of the sum of squared <span class="math inline">\(x\)</span> and <span class="math inline">\(z\)</span> components of <span class="math inline">\(\hat{n}_B^A\)</span>.</p>
<p>In formula, for <span class="math inline">\(B\times A = ((B\times A)_x, (B\times A)_y, (B\times A)_z )\)</span>:</p>
<p><span class="math display">\[
\tan\beta = \frac{\sin\beta}{\cos\beta} = \frac{\sqrt{ (B\times A)_x^2 + (B\times A)_z^2 }}{ (B\times A)_y^2}
\]</span></p>
<p>Now remains to compute <span class="math inline">\(B\times A\)</span> in the rotated coordinate system, and to invert the tangent, that does not have the issue we had when inverting the cosine.</p>
<p>The 3 points <span class="math inline">\(N, A, B\)</span> before re-orienting the axis are:</p>
<p><span class="math display">\[
\begin{align*}
N &amp;= (0,0,1) \\
A &amp;= (R\cos\varphi_A\cos\theta_A, R\cos\varphi_A\sin\theta_A, R\sin\varphi_A) \\
B &amp;= (R\cos\varphi_B\cos\theta_B, R\cos\varphi_B\sin\theta_B, R\sin\varphi_B)
\end{align*}
\]</span></p>
<p>After the re-orientation <span class="math inline">\(\theta_A = 0\)</span> and <span class="math inline">\(\tilde{\theta}_B = \theta_B - \theta_A\)</span> they become:</p>
<p><span class="math display">\[
\begin{align*}
N &amp;= (0,0,1) \\
A &amp;= (R\cos\varphi_A, 0, R\sin\varphi_A) \\
B &amp;= (R\cos\varphi_B\cos\tilde{\theta}_B, R\cos\varphi_B\sin\tilde{\theta}_B, R\sin\varphi_B)
\end{align*}
\]</span></p>
<p>With elementary computations based on: <span class="math display">\[
\begin{align*}
N \times A = &amp;(0, R\cos\varphi_A, 0) \\
B\times A = &amp;( R^2 \sin\varphi_A  \cos\varphi_B \sin\tilde{\theta}_B, R^2 \cos\varphi_A \sin\varphi_B - \sin\varphi_A \cos\varphi_B \cos\tilde{\theta}_B,  - R^2 \cos\varphi_A\cos\varphi_B \sin\tilde{\theta}_B   ) \\
\end{align*}
\]</span></p>
<p>it follows: <span class="math display">\[
\begin{align*}
\tan\beta &amp;= \frac{\sqrt{ (B\times A)_x^2 + (B\times A)_z^2 }}{ (B\times A)_y^2} \\
          &amp;= \frac{ \sqrt{ \cos^2\varphi_B \sin^2\tilde{\theta}_B ( \sin^2\varphi_A + \cos^2\varphi_A) }  }{\cos\varphi_A \sin\varphi_B - \sin\varphi_A \cos\varphi_B \cos\tilde{\theta}_B} \\
          &amp;= \frac{\cos\varphi_B \sin\tilde{\theta}_B }{\cos\varphi_A \sin\varphi_B - \sin\varphi_A \cos\varphi_B \cos\tilde{\theta}_B}
\end{align*}
\]</span></p>
<p>Applying the arc-tangent to both members of the previous expressions, we finally get to the <strong>solution</strong> to the problem of computing the bearing:</p>
<p><span class="math display">\[
\beta(A, B) = \text{atan2} ( Y, X )
\]</span></p>
<p>where</p>
<p><span class="math display">\[
\begin{align*}
Y &amp;:= \cos\varphi_B \sin(\theta_B - \theta_A) \\
X &amp;:= \cos\varphi_A \sin\varphi_B - \sin\varphi_A \cos\varphi_B \cos(\theta_B - \theta_A) \\
\end{align*}
\]</span></p>
<p>and where <span class="math inline">\(\text{atan2}(y, x)\)</span> is the arctangent of <span class="math inline">\(y/x\)</span>, evaluated for any <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> as</p>
<p><span class="math display">\[
\text{atan2}(y, x)
=
\begin{cases}
  \arctan(y/x) \phantom{+ \pi} \qquad x&gt;0, ~~\forall y  \\
  \arctan(y/x) + \pi \qquad x&lt;0, ~~ y \geq 0  \\
  \arctan(y/x) - \pi \qquad x&lt;0, ~~ y &lt; 0  \\
  +\frac{\pi}{2} \phantom{\arctan(y/x)} \qquad x = 0, ~~ y &gt; 0  \\
  -\frac{\pi}{2} \phantom{\arctan(y/x)} \qquad x = 0, ~~ y &lt; 0  \\
  \text{undefined} \qquad \qquad x = 0, ~~ y = 0  \\
\end{cases}
\]</span></p>
</section>
<section id="sec-ellipsoid-model" class="level2">
<h2 class="anchored" data-anchor-id="sec-ellipsoid-model">Bearings for the Earth’s ellipsoid model</h2>
<p>Here we compute the Bearing on the ellipsoid. In analogy with the Haversine distance formula on the sphere, that becomes the Vincentry’s distance formula when computed on the ellipsoid, we may call this formulation the <code>Vincentry's bearing</code><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<p>The projection from the sphere to to the ellipsoid immersed in the 3D space that we use here is:</p>
<p><span class="math display">\[
\iota_e: \mathbb{S}^2 \rightarrow  \mathbb{R}^3
\]</span></p>
<p><span class="math display">\[
\iota_e(\theta, \varphi) = \begin{cases}
       x = R \cos\varphi \cos\theta\\
       y = R \cos\varphi \sin\theta\\
       z = r \sin\varphi\\
     \end{cases}
\]</span></p>
<p>where to <span class="math inline">\(R=6378~\text{Km}\)</span> corresponds the lengths of the semi-axes parallel to the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> coordinates, and <span class="math inline">\(r=6357~\text{Km}\)</span> is the length of the semi-axis parallel to the <span class="math inline">\(z\)</span> axis. Following the same reasoning and re-orientation of the previous section we have:</p>
<p><span class="math display">\[
\begin{align*}
N &amp;= (0,0,1) \\
A &amp;= (R\cos\varphi_A, 0, r\sin\varphi_A) \\
B &amp;= (R\cos\varphi_B\cos\tilde{\theta}_B, R\cos\varphi_B\sin\tilde{\theta}_B, r\sin\varphi_B)
\end{align*}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
B\times A = &amp;( r R \sin\varphi_A  \cos\varphi_B \sin\tilde{\theta}_B, r R \cos\varphi_A \sin\varphi_B - r R \sin\varphi_A \cos\varphi_B \cos\tilde{\theta}_B,  - R^2 \cos\varphi_A\cos\varphi_B \sin\tilde{\theta}_B   ) \\
\end{align*}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
\tan\beta_e &amp;= \frac{\sqrt{ (B\times A)_x^2 + (B\times A)_z^2 }}{ (B\times A)_y^2} \\
          &amp;= \frac{
            \sqrt{
                R^2 r^2 \sin^2\varphi_A \cos^2\varphi_B \sin^2\tilde{\theta}_B + R^4 \cos^2\varphi_A \cos^2\varphi_B \sin^2\tilde{\theta}_B
            }  
           }{
           R r(\cos\varphi_A \sin\varphi_B - \sin\varphi_A \cos\varphi_B \cos\tilde{\theta}_B )
        }
\end{align*}
\]</span></p>
<p>As a consequence, the bearing on the ellipsoid <span class="math inline">\(\beta_e\)</span> between the points <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> can be computed with:</p>
<p><span class="math display">\[
\beta_e(A, B) = \text{atan2} ( Y, X )
\]</span></p>
<p>where</p>
<p><span class="math display">\[
\begin{align*}
Y &amp;:= \sqrt{
                R^2 r^2 \sin^2\varphi_A \cos^2\varphi_B \sin^2\tilde{\theta}_B + R^2 \cos^2\varphi_A \cos^2\varphi_B \sin^2\tilde{\theta}_B
            }  \\
X &amp;:= R r(\cos\varphi_A \sin\varphi_B - \sin\varphi_A \cos\varphi_B \cos\tilde{\theta}_B ) \\
\end{align*}
\]</span></p>
<p>Now wait! Looking back at the definition of <span class="math inline">\(\text{atan2}(y, x)\)</span>, and at the fact that <span class="math inline">\(Y\)</span> is always positive (unlike on the sphere were it was possible to get rid of the square root), we can see that we have the same issue we had when inverting the cosine in the previous section. The formula would work only for the angles pointing eastwards, as the angle would fold back between <span class="math inline">\([0, \pi]\)</span> for all the angles pointing westwards.</p>
<p>To solve the problem in this direction, we must add a multiplicative sign factor <span class="math inline">\(\sigma\)</span> that is positive if <span class="math inline">\((\text{Lon}_B - \text{Lon}_A) ~ \text{mod} ~ 360 \leq 180\)</span>, and negative otherwise.</p>
<p><span class="math display">\[
\beta_e(A, B) = \sigma ~\text{atan2} ( Y, X )
\]</span></p>
<p>where</p>
<p><span class="math display">\[
\sigma =
\begin{cases}
  +1 \qquad (\text{Lon}_B - \text{Lon}_A) ~ \text{mod} ~ 360 \le 180  \\
  -1 \qquad (\text{Lon}_B - \text{Lon}_A) ~ \text{mod} ~ 360 &gt; 180  \\
\end{cases}
\]</span></p>
<p>Even with this extra sing, I personally prefer to rely on the arcotangent instead of directly inverting the cosine in the scalar product formula, due to the complications arising normalising the vectors involved (in particular in normalising <span class="math inline">\(B \times A\)</span> after the axis rotation).</p>
<p>Nonetheless, computing the bearing as</p>
<p><span class="math display">\[
\beta = \sigma \arccos\left(
    \frac{
            \hat{n}_B^A \cdot \hat{n}_N^A
        }
        {
            \left\Vert \hat{n}_B^A \right\Vert  \left\Vert \hat{n}_N^A \right\Vert
    }
\right)
\]</span></p>
<p>remains a very valid option and a simple approach relying on the help of a numeric library.</p>
<section id="crossing-the-anti-meridian" class="level3">
<h3 class="anchored" data-anchor-id="crossing-the-anti-meridian">Crossing the anti-meridian</h3>
<p>The attentive reader may have noticed<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> that for the formula based on the cosine there is no <span class="math inline">\(z\)</span>-axis rotation bringing <span class="math inline">\(A\)</span> on the zero meridian. This rotation is still advisable in the practical implementations, to avoid the points crossing the anti-meridian.</p>
</section>
</section>
<section id="sec-coding" class="level2">
<h2 class="anchored" data-anchor-id="sec-coding">Python code</h2>
<p>Run with python 3.12 with only <code>numpy&gt;=2.1.0</code> installed. Most likely backward compatible with any previous version as based only on basic numpy functions.</p>
<div id="cell-9" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bearing(</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    lon_A: <span class="bu">float</span>,</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    lat_A: <span class="bu">float</span>,</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    lon_B: <span class="bu">float</span>,</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    lat_B: <span class="bu">float</span>,</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Angle between geodesic connecting point 1 to point 2, and point 1 and north pole.</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Input latitude and longitude expected in degrees.</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co">    Result in degrees between 0 to 360.</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> np.nan <span class="kw">in</span> [lon_A, lat_A, lon_B, lat_B]:</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.nan</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    theta_A, phi_A, theta_B, phi_B <span class="op">=</span> <span class="bu">map</span>(np.radians, [lon_A, lat_A, lon_B, lat_B])</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.cos(phi_B) <span class="op">*</span> np.sin(theta_B <span class="op">-</span> theta_A)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.cos(phi_A) <span class="op">*</span> np.sin(phi_B) <span class="op">-</span> np.sin(phi_A) <span class="op">*</span> np.cos(phi_B) <span class="op">*</span> np.cos(theta_B <span class="op">-</span> theta_A)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (np.rad2deg(np.arctan2(y, x)) <span class="op">+</span> <span class="dv">360</span>) <span class="op">%</span> <span class="dv">360</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bearing_ellipsoid(</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    lon_A: <span class="bu">float</span>,</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    lat_A: <span class="bu">float</span>,</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    lon_B: <span class="bu">float</span>,</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    lat_B: <span class="bu">float</span>,</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    polar_radius_km: <span class="bu">float</span> <span class="op">=</span> <span class="fl">6357.0</span>,</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    equatorial_radius_km: <span class="bu">float</span> <span class="op">=</span> <span class="fl">6378.0</span>,</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="co">    Angle between geodesic connecting point 1 to point 2, and point 1 and north pole.</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="co">    Default to WGS84 ellipsoid model.</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="co">    Input latitude and longitude expected in degrees.</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="co">    Result in degrees between 0 to 360.</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> np.nan <span class="kw">in</span> [lon_A, lat_A, lon_B, lat_B]:</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.nan</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    theta_A, phi_A, theta_B, phi_B <span class="op">=</span> <span class="bu">map</span>(np.radians, [lon_A, lat_A, lon_B, lat_B])</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    R, r <span class="op">=</span> equatorial_radius_km, polar_radius_km</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.sqrt(</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        (R <span class="op">*</span> r <span class="op">*</span> np.sin(phi_A) <span class="op">*</span> np.cos(phi_B) <span class="op">*</span> np.sin(theta_B <span class="op">-</span> theta_A)) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span> (R<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> np.cos(phi_A) <span class="op">*</span> np.cos(phi_B) <span class="op">*</span> np.sin(theta_B <span class="op">-</span> theta_A)) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="op">-</span>(R<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> np.cos(phi_B) <span class="op">*</span> np.sin(phi_A) <span class="op">*</span> np.cos(theta_B <span class="op">-</span> theta_A) <span class="op">+</span> r <span class="op">*</span> R <span class="op">*</span> np.cos(phi_A) <span class="op">*</span> np.sin(phi_B)</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span> <span class="op">+</span><span class="dv">1</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (lon_B <span class="op">-</span> lon_A) <span class="op">%</span> <span class="dv">360</span> <span class="op">&gt;</span> <span class="dv">180</span>:</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>        sigma <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (np.rad2deg(sigma <span class="op">*</span> np.arctan2(y, x)) <span class="op">+</span> <span class="dv">360</span>) <span class="op">%</span> <span class="dv">360</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _lon_lat_to_3d(</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>    lon: <span class="bu">float</span>,</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    lat: <span class="bu">float</span>,</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    polar_radius_km: <span class="bu">float</span> <span class="op">=</span> <span class="fl">6357.0</span>,</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>    equatorial_radius_km: <span class="bu">float</span> <span class="op">=</span> <span class="fl">6378.0</span>,</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""aux function to compute projections"""</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>    theta, phi <span class="op">=</span> <span class="bu">map</span>(np.radians, [lon, lat])</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    R, r <span class="op">=</span> equatorial_radius_km, polar_radius_km</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([R <span class="op">*</span> np.cos(phi) <span class="op">*</span> np.cos(theta), R <span class="op">*</span> np.cos(phi) <span class="op">*</span> np.sin(theta), r <span class="op">*</span> np.sin(phi)])</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bearing_ellipsoid_cos(</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>    lon_A: <span class="bu">float</span>,</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>    lat_A: <span class="bu">float</span>,</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>    lon_B: <span class="bu">float</span>,</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>    lat_B: <span class="bu">float</span>,</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>    polar_radius_km: <span class="bu">float</span> <span class="op">=</span> <span class="fl">6357.0</span>,</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>    equatorial_radius_km: <span class="bu">float</span> <span class="op">=</span> <span class="fl">6378.0</span>,</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a><span class="co">    Angle between geodesic connecting point 1 to point 2, and point 1 and north pole.</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a><span class="co">    Default to WGS84 ellipsoid model.</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a><span class="co">    Input latitude and longitude expected in degrees.</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a><span class="co">    Result in degrees between 0 to 360.</span></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a><span class="co">    Alternative method based on inverting the cosine, and using the vector projection with normalization</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a><span class="co">    and vector product of numpy.</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>    lon_B <span class="op">=</span> lon_B <span class="op">-</span> lon_A</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>    lon_A <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> _lon_lat_to_3d(lon_A, lat_A, polar_radius_km, equatorial_radius_km)</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> _lon_lat_to_3d(lon_B, lat_B, polar_radius_km, equatorial_radius_km)</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>    n_N_A, n_B_A <span class="op">=</span> np.cross(N, A), np.cross(B, A)</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>    n_N_A <span class="op">=</span> n_N_A <span class="op">/</span> np.linalg.norm(n_N_A)</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>    n_B_A <span class="op">=</span> n_B_A <span class="op">/</span> np.linalg.norm(n_B_A)</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span> <span class="op">+</span><span class="dv">1</span></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (lon_B <span class="op">-</span> lon_A) <span class="op">%</span> <span class="dv">360</span> <span class="op">&gt;</span> <span class="dv">180</span>:</span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>        sigma <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (np.rad2deg(sigma <span class="op">*</span> np.arccos(np.dot(n_N_A, n_B_A))) <span class="op">+</span> <span class="dv">360</span>) <span class="op">%</span> <span class="dv">360</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The two functions are tested on a grid of points centered on the null island, and distributed clockwise for intervals of 45 degrees angles.</p>
<p>With this experiment we can see the different formulas at work, and how the bearing changes in accordance with changing <span class="math inline">\(r\)</span>. An angle that would be close to 45 degrees in the spherical model (point <span class="math inline">\(B_2\)</span>, <span class="math inline">\(r = R\)</span>) would shrink on an elongated spherical model (point <span class="math inline">\(B_1\)</span>, <span class="math inline">\(r &gt;&gt; R\)</span>), and would become close to 90 degrees on a flattened model (point <span class="math inline">\(B_3\)</span>, <span class="math inline">\(r &lt;&lt; R\)</span>). We also compare the cosine formula and the ellipsoid formula with WGS84 parameters.</p>
<div id="fig-experiments" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-experiments-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/figure_3_experiments.png" id="fig-experiments" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-experiments-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3
</figcaption>
</figure>
</div>
<div id="cell-12" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_list_lon_lat_45(radius: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1.0</span>) <span class="op">-&gt;</span> <span class="bu">list</span>[<span class="bu">float</span>]:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Dataset constructor, clockwise from lon,lat=0,1. Radius in degrees."""</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    cos, sin <span class="op">=</span> np.sqrt(<span class="dv">2</span>) <span class="op">/</span> <span class="dv">2</span>, np.sqrt(<span class="dv">2</span>) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        [<span class="fl">0.0</span>, radius],</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        [radius <span class="op">*</span> cos, radius <span class="op">*</span> sin],</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        [radius <span class="op">*</span> radius, <span class="fl">0.0</span>],</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        [radius <span class="op">*</span> cos, <span class="op">-</span>radius <span class="op">*</span> sin],</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        [<span class="fl">0.0</span>, <span class="op">-</span>radius <span class="op">*</span> radius],</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        [<span class="op">-</span>radius <span class="op">*</span> cos, <span class="op">-</span>radius <span class="op">*</span> sin],</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        [<span class="op">-</span>radius <span class="op">*</span> radius, <span class="fl">0.0</span>],</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        [<span class="op">-</span>radius <span class="op">*</span> cos, radius <span class="op">*</span> sin],</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>expected_angles_deg <span class="op">=</span> <span class="dv">45</span> <span class="op">*</span> np.arange(<span class="dv">0</span>, <span class="dv">8</span>, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>lon_A, lat_A <span class="op">=</span> <span class="fl">0.0</span>, <span class="fl">0.0</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> radius <span class="kw">in</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">20</span>]:</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> expected_bearing, (lon_B, lat_B) <span class="kw">in</span> <span class="bu">zip</span>(expected_angles_deg, get_list_lon_lat_45(radius)):</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        computed_bearing <span class="op">=</span> bearing(lon_A, lat_A, lon_B, lat_B)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        computed_bearing_b1 <span class="op">=</span> bearing_ellipsoid(</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>            lon_A, lat_A, lon_B, lat_B, polar_radius_km<span class="op">=</span><span class="dv">20_000</span>, equatorial_radius_km<span class="op">=</span><span class="dv">6378</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        computed_bearing_b2 <span class="op">=</span> bearing_ellipsoid(</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>            lon_A, lat_A, lon_B, lat_B, polar_radius_km<span class="op">=</span><span class="dv">6378</span>, equatorial_radius_km<span class="op">=</span><span class="dv">6378</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        computed_bearing_b3 <span class="op">=</span> bearing_ellipsoid(</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>            lon_A, lat_A, lon_B, lat_B, polar_radius_km<span class="op">=</span><span class="dv">20</span>, equatorial_radius_km<span class="op">=</span><span class="dv">6378</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        computed_bearing_standard <span class="op">=</span> bearing_ellipsoid(lon_A, lat_A, lon_B, lat_B)</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        computed_bearing_standard_cos <span class="op">=</span> bearing_ellipsoid_cos(lon_A, lat_A, lon_B, lat_B)</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># replace with `if True:`, to see all results</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> radius <span class="op">==</span> <span class="dv">20</span> <span class="kw">and</span> expected_bearing <span class="kw">in</span> [<span class="fl">0.0</span>, <span class="fl">45.0</span>, <span class="fl">315.0</span>]:</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"--------------"</span>)</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"on the plane   = </span><span class="sc">{</span>expected_bearing<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"on the sphere  = </span><span class="sc">{</span>computed_bearing<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"comp. elli. B1 = </span><span class="sc">{</span>computed_bearing_b1<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"comp. elli. B2 = </span><span class="sc">{</span>computed_bearing_b2<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"comp. elli. B3 = </span><span class="sc">{</span>computed_bearing_b3<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"comp. elli.    = </span><span class="sc">{</span>computed_bearing_standard<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"comp. cos.     = </span><span class="sc">{</span>computed_bearing_standard_cos<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>--------------
on the plane   = 0.0
on the sphere  = 0.0
comp. elli. B1 = 0.0
comp. elli. B2 = 0.0
comp. elli. B3 = 0.0
comp. elli.    = 0.0
comp. cos.     = 0.0

--------------
on the plane   = 45.0
on the sphere  = 44.11846688848101
comp. elli. B1 = 17.18343754925604
comp. elli. B2 = 44.11846688848101
comp. elli. B3 = 89.81471830327064
comp. elli.    = 44.212907540129606
comp. cos.     = 44.212907540129606

--------------
on the plane   = 315.0
on the sphere  = 315.881533111519
comp. elli. B1 = 342.81656245074396
comp. elli. B2 = 315.881533111519
comp. elli. B3 = 270.18528169672936
comp. elli.    = 315.7870924598704
comp. cos.     = 315.7870924598704
</code></pre>
</div>
</div>
<!-- 
Explorations for the future:

https://math.libretexts.org/Bookshelves/Abstract_and_Geometric_Algebra/Introduction_to_Groups_and_Geometries_(Lyons)/03%3A_Geometries/3.04%3A_Elliptic_geometry

https://geodaesie.info/images/zfv/147-jahrgang-2022/downloads/zfv_2022_3_Lapaine.pdf 

Karney paper
https://link.springer.com/article/10.1007/s00190-012-0578-z
-->


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p><a href="https://www.math.fsu.edu/~wxm/Arnold.htm#:~:text=Mathematics%20is%20the%20part%20of,be%20discovered%20with%20less%20expense">V. Arnold’s letter</a> describing a very common definition of mathematics.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>consider <span class="math inline">\(A\times N\)</span> and <span class="math inline">\(A\times B\)</span> leads to identical results.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>I could not find this formula on the web or on any other resources. It may not have been considered worth writing about, probably because it is a very simple variation of the algebraic manipulations proposed in the previous section. Or maybe because of its ugliness.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>This expression is lend from proper maths textbooks, and in this post it is written with an optimistic spirit in believing to have any reader at all.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/sebastianof\.github\.io\/GeoDsBlog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Blog made with <a href="https://quarto.org/">Quarto</a>, by Sebastiano Ferraris. License: <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC BY-SA 2.0</a>.</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/sebastianof/">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="mailto:sebastiano.ferraris@gmail.com">
      <i class="bi bi-envelope" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>