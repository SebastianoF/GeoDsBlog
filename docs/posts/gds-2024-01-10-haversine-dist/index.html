<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.47">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-01-13">

<title>Haversine’s distance mathematics – A Geospatial Data Science Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../images/favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-VPPV7D4HSQ"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-VPPV7D4HSQ', { 'anonymize_ip': true});
</script>
<style>html{ scroll-behavior: smooth; }</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta name="twitter:title" content="Haversine’s distance mathematics – A Geospatial Data Science Blog">
<meta name="twitter:description" content="Computing the distance between two points on a sphere">
<meta name="twitter:image" content="https://sebastianof.github.io/GeoDsBlog/posts/gds-2024-01-10-haversine-dist/images/cover.png">
<meta name="twitter:image-height" content="932">
<meta name="twitter:image-width" content="1662">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">A Geospatial Data Science Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-posts" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Posts</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-posts">    
        <li>
    <a class="dropdown-item" href="../../posts/all.html">
 <span class="dropdown-text">All posts</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../posts/gds.html">
 <span class="dropdown-text">Geospatial Data Science</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../posts/bp.html">
 <span class="dropdown-text">Code development</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-about" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">About</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-about">    
        <li>
    <a class="dropdown-item" href="../../about/about.html">
 <span class="dropdown-text">Author</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../about/CV_modern/curriculum.pdf">
 <span class="dropdown-text">CV</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/sebastianof/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:sebastiano.ferraris@gmail.com"> <i class="bi bi-envelope" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Haversine’s distance mathematics</h1>
            <p class="subtitle lead">Computing the distance between two points on a sphere</p>
                                <div class="quarto-categories">
                <div class="quarto-category">tutorial</div>
                <div class="quarto-category">geospatial</div>
                <div class="quarto-category">mathematics</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 13, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#sec-spherical-model" id="toc-sec-spherical-model" class="nav-link" data-scroll-target="#sec-spherical-model">Earth’s Spherical Model</a></li>
  <li><a href="#sec-map-projection" id="toc-sec-map-projection" class="nav-link" data-scroll-target="#sec-map-projection">Map Projection on the Sphere Experiments</a></li>
  <li><a href="#sec-two-points-distance" id="toc-sec-two-points-distance" class="nav-link" data-scroll-target="#sec-two-points-distance">Two Points’ Distance</a></li>
  <li><a href="#sec-haversine-distance" id="toc-sec-haversine-distance" class="nav-link" data-scroll-target="#sec-haversine-distance">Haversine Distance</a></li>
  <li><a href="#sec-implementation" id="toc-sec-implementation" class="nav-link" data-scroll-target="#sec-implementation">Implementation and examples</a></li>
  <li><a href="#sec-numerical-stability" id="toc-sec-numerical-stability" class="nav-link" data-scroll-target="#sec-numerical-stability">Numerical stability</a></li>
  <li><a href="#sec-vincentry-formula" id="toc-sec-vincentry-formula" class="nav-link" data-scroll-target="#sec-vincentry-formula">See also: Vincenty’s formula</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><img src="images/cover.png" class="img-fluid"></p>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>This blog post is for the reader interested in building an intuition for how distances on the sphere are computed (<a href="#sec-map-projection" class="quarto-xref">Section&nbsp;3</a>, <a href="#sec-two-points-distance" class="quarto-xref">Section&nbsp;4</a>), to understand the details of the maths behind the Haversine distance (<a href="#sec-haversine-distance" class="quarto-xref">Section&nbsp;5</a>), to have an implementation in python with some examples and details about the numerical stability (<a href="#sec-implementation" class="quarto-xref">Section&nbsp;6</a>, <a href="#sec-numerical-stability" class="quarto-xref">Section&nbsp;7</a>), and a conclusion about what to use in the python practice (<a href="#sec-vincentry-formula" class="quarto-xref">Section&nbsp;8</a>). This last one is the only section you should look at if you are here to compute the Haversine distance quickly and accurately.</p>
<p>The article starts with the somehow pedantic though possibly important section about the motivations and formulas behind the spherical model.</p>
<p><img src="images/earth_models.png" class="img-fluid"></p>
</section>
<section id="sec-spherical-model" class="level2">
<h2 class="anchored" data-anchor-id="sec-spherical-model">Earth’s Spherical Model</h2>
<p>In any dimension, the most symmetric geometrical object is the sphere. Unlike planes, spheres are also symmetric when considered within their embedding in an higher dimensional space.</p>
<p>Even though the earth is not a perfect sphere, also for its symmetric properties, the 2D sphere embedded in the 3D space is a very reasonable earth’s approximation. Amongst the models that are more accurate we can find the ellipsoid (which is the model used by the GPS systems, more precisely the <a href="https://en.wikipedia.org/wiki/World_Geodetic_System">WGS84 geodetic system</a>), the <a href="https://www.sciencedirect.com/topics/earth-and-planetary-sciences/geoids">geoid model</a>, or even the local <a href="https://geopard.tech/blog/topography-and-relief-analytics-for-agricultural-fields">topographic elevations</a>.</p>
<p>Which model is the best one?</p>
<p>If the local topography is not relevant and the computations has to be kept bare simple and fast, the sphere is the go to model of the earth. The conventional coordinates system, consisting of the pair longitude (East-West direction) and latitude (North-South direction) measured in degrees from the center of the modelling surface in the 3D space, can be projected in any of the mentioned model, and even more, such as the cylindrical, conical and plane model.</p>
<p>Adding the radius as third coordinate, we can model the altitude for each point. Unlike latitude and longitude, the location of the zero for the altitude point is model-dependent, and will be different if on the sphere, the ellipsoid or others. The functions mapping the latitude, longitude (and altitude) coordinates across models are called <a href="https://en.wikipedia.org/wiki/Map_projection">maps projections</a><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>For a fixed radius <span class="math inline">\(R\)</span>, and for <span class="math inline">\(\text{rad}: \text{Deg} \rightarrow \text{Rad}\)</span> the function mapping degrees to radians, we can rename the two angles with the radians with the conventional greek letters <span class="math inline">\(\theta\)</span> (theta) and <span class="math inline">\(\varphi\)</span> (phi):</p>
<p><span class="math display">\[
\begin{align*}
\theta &amp;:= \text{rad}(\text{Lon}) \\
\varphi &amp;:= \text{rad}(\text{Lat}) \\
\end{align*}
\]</span></p>
<p>Another basic map for the spherical model is the immersion from the sphere to the 3D space</p>
<p><span class="math display">\[
\iota: \mathbb{S}^2 \rightarrow  \mathbb{R}^3
\]</span></p>
<p>that projects each pair <span class="math inline">\((\theta, \varphi)\)</span> for <span class="math inline">\(\theta \in [-\pi, \pi]\)</span> and <span class="math inline">\(\varphi \in [-\pi/2, \pi/2]\)</span> on the sphere of radius <span class="math inline">\(R\)</span>:</p>
<p><span class="math display">\[
\iota(\theta, \varphi) = \begin{cases}
       x = R \cos(\varphi) \cos(\theta)\\
       y = R \cos(\varphi) \sin(\theta)\\
       z = R \sin(\varphi)\\
     \end{cases}
\]</span></p>
<p>The function <span class="math inline">\(\iota\)</span> is one of the many map projections, and the only one we will consider in this blog post; the reasoning behind its formulation can be derived from the definition of sine and cosine and from the drawing below.</p>
<div id="fig-spherical-coordinates" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-spherical-coordinates-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/spherical_coordinates.png" id="fig-spherical-coordinates" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-spherical-coordinates-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
</figcaption>
</figure>
</div>
<p>Please note that most mathematical textbooks have the angle <span class="math inline">\(\varphi\)</span> at zero when the point in on the z-axis, so <span class="math inline">\(\sin\)</span> and <span class="math inline">\(\cos\)</span> are swapped, and the angle’s domain would be <span class="math inline">\([0,\pi]\)</span>. In this blot post and to remain faithful to the definition of latitude, we consider <span class="math inline">\(\varphi\)</span> at zero when the point is on the xy-plane with domain <span class="math inline">\([-\pi/2,\pi/2]\)</span>.</p>
<!-- Footnote -->
</section>
<section id="sec-map-projection" class="level2">
<h2 class="anchored" data-anchor-id="sec-map-projection">Map Projection on the Sphere Experiments</h2>
<p>To check all is working correctly we will plot on the 3D sphere a sequence of equidistant points around the equator (in red), around the tropic of Cancer (in green), around the Arctic Polar circle (of course in blue), and then the cities of Rome, Paris and London (in black). To show a visual reference to make sense of the position of these three cities, we also plot the meridian zero (in gray).</p>
<div id="cell-3" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>R_Km <span class="op">=</span> <span class="dv">6371</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lon_lat_to_3d(lon, lat):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    theta, phi <span class="op">=</span> <span class="bu">map</span>(np.radians, [lon, lat])</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> R_Km <span class="op">*</span> np.cos(phi) <span class="op">*</span> np.cos(theta)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> R_Km <span class="op">*</span> np.cos(phi) <span class="op">*</span> np.sin(theta)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> R_Km <span class="op">*</span> np.sin(phi)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (x, y, z)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-4" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">40</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Create N equidistant points around the equator</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>lon_at_equator_deg <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">360</span>, N)[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>lat_at_equator_deg <span class="op">=</span> <span class="dv">0</span> <span class="op">*</span> np.ones_like(lon_at_equator_deg)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Create N equidistant points around the tropic of cancer</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>lon_at_tropic_deg <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">360</span>, N)[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>lat_at_tropic_deg <span class="op">=</span> <span class="fl">23.43617</span> <span class="op">*</span> np.ones_like(lon_at_tropic_deg)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Create N equidistant points around the north pole</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>lon_at_arctic_deg <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">360</span>, N)[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>lat_at_arctic_deg <span class="op">=</span> <span class="fl">76.25</span> <span class="op">*</span> np.ones_like(lon_at_arctic_deg)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Create N equidistant points at meridian 0</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>lat_at_meridian_deg <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">90</span>, <span class="dv">90</span>, N)[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>lon_at_meridian_deg <span class="op">=</span> np.ones_like(lat_at_meridian_deg) </span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co"># a selection of 3 cities</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>lon_lat_london <span class="op">=</span> ( <span class="fl">0.1276</span>, <span class="fl">51.5072</span>)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>lon_lat_paris  <span class="op">=</span> ( <span class="fl">2.3522</span>, <span class="fl">48.8566</span>)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>lon_lat_rome   <span class="op">=</span> (<span class="fl">12.4964</span>, <span class="fl">41.9028</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-5" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">111</span>, projection<span class="op">=</span><span class="st">'3d'</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Sphere surface</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>lon, lat <span class="op">=</span> np.mgrid[<span class="op">-</span><span class="dv">90</span>:<span class="dv">90</span>:<span class="ot">100j</span>, <span class="fl">0.0</span>:<span class="dv">360</span>:<span class="ot">100j</span>]</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>x, y , z <span class="op">=</span> lon_lat_to_3d(lon, lat)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>ax.plot_surface(x, y, z,  rstride<span class="op">=</span><span class="dv">1</span>, cstride<span class="op">=</span><span class="dv">1</span>, color<span class="op">=</span><span class="st">"#303E4F"</span>, alpha<span class="op">=</span><span class="fl">0.2</span>, linewidth<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Parallels</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>xx_equator, yy_equator, zz_equator <span class="op">=</span> lon_lat_to_3d(lon_at_equator_deg, lat_at_equator_deg)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>ax.scatter(xx_equator, yy_equator, zz_equator, color<span class="op">=</span><span class="st">"r"</span>,s<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>xx_tropic, yy_tropic, zz_tropic <span class="op">=</span> lon_lat_to_3d(lon_at_tropic_deg, lat_at_tropic_deg)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>ax.scatter(xx_tropic , yy_tropic, zz_tropic, color<span class="op">=</span><span class="st">"g"</span>,s<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>xx_arctic, yy_arctic, zz_arctic <span class="op">=</span> lon_lat_to_3d(lon_at_arctic_deg, lat_at_arctic_deg)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>ax.scatter(xx_arctic, yy_arctic, zz_arctic, color<span class="op">=</span><span class="st">"b"</span>,s<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Meridian</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>xx_meridian, yy_meridian, zz_meridian <span class="op">=</span> lon_lat_to_3d(lon_at_meridian_deg, lat_at_meridian_deg)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>ax.scatter(xx_meridian, yy_meridian, zz_meridian, color<span class="op">=</span><span class="st">"gray"</span>,s<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Cities</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>cities <span class="op">=</span> [lon_lat_london, lon_lat_paris, lon_lat_rome]</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>lon_cities <span class="op">=</span> [a[<span class="dv">0</span>] <span class="cf">for</span> a <span class="kw">in</span> cities]</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>lat_cities <span class="op">=</span> [a[<span class="dv">1</span>] <span class="cf">for</span> a <span class="kw">in</span> cities]</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>xx_cities, yy_cities, zz_cities <span class="op">=</span> lon_lat_to_3d(lon_cities, lat_cities)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>ax.scatter(xx_cities, yy_cities, zz_cities, color<span class="op">=</span><span class="st">"k"</span>,s<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>ax.set_aspect(<span class="st">"equal"</span>)</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-4-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>From the plot above we can see that all works as expected, including the fact that the points at the tropic of cancer, even if they have the same longitude spacing as the point on the equator, have a significantly smaller mutual distance. They obviously come close to each other when approaching the north pole, becoming a single point at the pole itself.</p>
<p>If we want to keep the same “horizontal distance” or the distance on the tropic of Cancer as we have it at the equator, then we have to consider a smaller radius (that is the radius that varies in function of the latitude and that is given by <span class="math inline">\(R\cos(\varphi)\)</span>) instead of the radius at the equator (that is <span class="math inline">\(R\)</span>).</p>
<p>The drawing below may convince you about the need to multiply by the cosine of the latitude to have the sought result.</p>
<div id="fig-radius-at-latitude" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-radius-at-latitude-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/radius_at_latitude.png" id="fig-radius-at-latitude" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-radius-at-latitude-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
</figcaption>
</figure>
</div>
<p>So now we know how to adjust for the number of points to maintain their distance equal while modulating the latitude.</p>
<div id="cell-8" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> num_points_at_latitude(num_points, latitude_deg):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">int</span>(num_points <span class="op">*</span> np.cos(np.radians(latitude_deg)))</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create N equidistant points around the equator</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>lon_at_equator_deg <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">360</span>, N)[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>lat_at_equator_deg <span class="op">=</span> <span class="dv">0</span> <span class="op">*</span> np.ones_like(lon_at_equator_deg)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Create equidistant points around the tropic of cancer, as at the equator</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>N_tropic <span class="op">=</span> num_points_at_latitude(N, <span class="fl">23.43617</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>lon_at_tropic_deg <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">360</span>, N_tropic)[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>lat_at_tropic_deg <span class="op">=</span> <span class="fl">23.43617</span> <span class="op">*</span> np.ones_like(lon_at_tropic_deg)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Create equidistant points around the north pole, as at the equator</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>N_arctic <span class="op">=</span> num_points_at_latitude(N, <span class="fl">76.25</span>)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>lon_at_arctic_deg <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">360</span>, N_arctic)[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>lat_at_arctic_deg <span class="op">=</span> <span class="fl">76.25</span> <span class="op">*</span> np.ones_like(lon_at_arctic_deg)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"number of points"</span>)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"at the arctic: </span><span class="sc">{</span>N_arctic<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"at the tropic: </span><span class="sc">{</span>N_tropic<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"at the equator: </span><span class="sc">{</span>N<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>number of points
at the arctic: 9
at the tropic: 36
at the equator: 40</code></pre>
</div>
</div>
<div id="cell-9" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Repeated code from cells above</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">111</span>, projection<span class="op">=</span><span class="st">'3d'</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Sphere surface</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>lon, lat <span class="op">=</span> np.mgrid[<span class="op">-</span><span class="dv">90</span>:<span class="dv">90</span>:<span class="ot">100j</span>, <span class="fl">0.0</span>:<span class="dv">360</span>:<span class="ot">100j</span>]</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>x, y , z <span class="op">=</span> lon_lat_to_3d(lon, lat)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>ax.plot_surface(x, y, z,  rstride<span class="op">=</span><span class="dv">1</span>, cstride<span class="op">=</span><span class="dv">1</span>, color<span class="op">=</span><span class="st">"#303E4F"</span>, alpha<span class="op">=</span><span class="fl">0.2</span>, linewidth<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Parallels</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>xx_equator, yy_equator, zz_equator <span class="op">=</span> lon_lat_to_3d(lon_at_equator_deg, lat_at_equator_deg)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>ax.scatter(xx_equator, yy_equator, zz_equator, color<span class="op">=</span><span class="st">"r"</span>,s<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>xx_tropic, yy_tropic, zz_tropic <span class="op">=</span> lon_lat_to_3d(lon_at_tropic_deg, lat_at_tropic_deg)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>ax.scatter(xx_tropic , yy_tropic, zz_tropic, color<span class="op">=</span><span class="st">"g"</span>,s<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>xx_arctic, yy_arctic, zz_arctic <span class="op">=</span> lon_lat_to_3d(lon_at_arctic_deg, lat_at_arctic_deg)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>ax.scatter(xx_arctic, yy_arctic, zz_arctic, color<span class="op">=</span><span class="st">"b"</span>,s<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>ax.set_aspect(<span class="st">"equal"</span>)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-6-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="sec-two-points-distance" class="level2">
<h2 class="anchored" data-anchor-id="sec-two-points-distance">Two Points’ Distance</h2>
<p>As said above, latitude and longitude coordinates are independent from the chosen model. The model we use to project the coordinates becomes relevant for computing the distance between two points.</p>
<p>The Haversine distance is the shortest distance between two points in longitude and latitude coordinates on a spherical model. Its unit of measurement is the same as the one passed as input for the radius.</p>
<p>Before introducing the Haversine distance between <span class="math inline">\(A = (\text{Lon}_{A}, \text{Lat}_{A})\)</span> and <span class="math inline">\(B = (\text{Lon}_{B}, \text{Lat}_{B})\)</span>, we start with two related concepts that can be seen as its approximation:</p>
<ul>
<li><strong>Euclidean distance</strong> between the corresponding points on the sphere: <span class="math display">\[
d_{\text{Eucl}}(A, B) = \lVert \iota(\varphi_{A}, \theta_{A}) - \iota(\varphi_{A}, \theta_{A}) \rVert = \sqrt{(x_B - x_A)^2 + (y_B - y_A)^2 + (z_B - z_A)^2}
\]</span> The formula above simply leverages on the Pythagorean theorem in respect to the 3D coordinate axis, and represents the distance we would travel if we could dig a straight tunnel connecting <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. It always underestimate the distance on the sphere, in the worst case by a factor of <span class="math inline">\(\pi \mathcal{R}\)</span> for <span class="math inline">\(\mathcal{R}\)</span> earth radius.</li>
</ul>
<p>The Euclidean distance is not very useful if we want to know the distance on the sphere!</p>
<p>Can we adjust for the curvature of the sphere getting inspired by <a href="#fig-radius-at-latitude" class="quarto-xref">Figure&nbsp;4</a>? For example we use the Pythagorean theorem on the surface of the sphere respect to the meridians and the parallels, and adjust for the fact that the latitude distance shrinks when moving away from the equator.</p>
<div id="fig-eucliean-spherical" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-eucliean-spherical-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/eucliean_spherical_distance.png" id="fig-eucliean-spherical" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-eucliean-spherical-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
</figcaption>
</figure>
</div>
<ul>
<li><p><strong>Distance of two points along the same meridian:</strong> introducing the point <span class="math inline">\(P = (\text{Lon}_{B}, \text{Lat}_{A})\)</span> that makes <span class="math inline">\(\bigtriangleup APB\)</span> a right triangle on the surface of the sphere, the arch <span class="math inline">\(\hat{BP}\)</span> runs along a meridian, and its length, converted to <span class="math inline">\(\text{Km}\)</span> for the radius <span class="math inline">\(\mathcal{R} = 6371~\text{Km}\)</span> is given by: <span class="math display">\[
\hat{BP} = \frac{2\pi \mathcal{R}}{360^{o}}\left\vert \text{Lat}_{B} - \text{Lat}_{P}\right\vert
= \frac{2\pi \mathcal{R}}{360^{o}}\vert \text{Lat}_{B} - \text{Lat}_{A}\vert
\]</span></p></li>
<li><p><strong>Distance of two points along the same parallel:</strong> as we saw, the distance along the arch <span class="math inline">\(\hat{AP}\)</span> is reduced by the cosine of the latitude, hence: <span class="math display">\[
\hat{AP} = \frac{2\pi \mathcal{R} \cos(\text{rad}(\text{Lat}_{A}))}{360^{o}}\left\vert \text{Lon}_{A} - \text{Lon}_{P}\right\vert
= \frac{2\pi \mathcal{R} \cos(\text{rad}(\text{Lat}_{A}))}{360^{o}}\vert \text{Lon}_{A} - \text{Lon}_{B}\vert
\]</span></p></li>
</ul>
<p>And so we can use again the Pythagorean theorem to compute <span class="math inline">\(\hat{AB}\)</span> as an Euclidean-spherical distance:</p>
<p><span class="math display">\[
d_{\text{Sph}}(A, B) = \sqrt{\hat{AP}^ 2 + \hat{BP}^2}
= \frac{2\pi \mathcal{R}}{360^{o}} \sqrt{ \cos^2(\text{rad}(\text{Lat}_{A}))(\text{Lon}_{A} - \text{Lon}_{B})^2 + (\text{Lat}_{A} - \text{Lat}_{B})^2  }
\]</span></p>
<p>This too is an approximation. Even if the lenghts of the sides of the triangle are exact, the curvature of the trajectory <span class="math inline">\(\hat{AB}\)</span> itself is not taken into account.</p>
</section>
<section id="sec-haversine-distance" class="level2">
<h2 class="anchored" data-anchor-id="sec-haversine-distance">Haversine Distance</h2>
<p>The examples proposed above are useful to develop some geometrical intuition about the distances on the sphere. The Haversine distance, provides us with a closed form solution to compute the length of the <em>geodesic</em> curve on the sphere, which is the shortest path on the surface of the sphere between the point <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>.</p>
<p>Thanks to the already mentioned symmetry, the geodesics is the arch defined by the intersection between the sphere and the plane passing through <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> and the centre of the sphere. This plane always cuts the sphere in half, and again by symmetry, and rotating the sphere so that <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are on the equator, it is easy to see why a curve made in this way is the shortest one (or why any other curve would be longer).</p>
<div id="fig-radius-at-latitude" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-radius-at-latitude-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/geodesic_on_the_sphere.png" id="fig-radius-at-latitude" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-radius-at-latitude-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
</figcaption>
</figure>
</div>
<p>Let <span class="math inline">\(d\)</span> be the sought geodesic distance between <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, and <span class="math inline">\(\lambda\)</span> the angle at the center of the sphere in radians. By definition of radians we have:</p>
<p><span class="math display">\[
\frac{d}{\mathcal{R}} = \lambda
\]</span> <span class="math display">\[
\frac{d}{\mathcal{R}} = 2 \frac{\lambda}{2}
\]</span> <span class="math display">\[
\frac{d}{\mathcal{R}} = 2 \arcsin \left(\sqrt{\sin^2(\lambda / 2 )}\right)
\]</span> <span class="math display">\[
d = 2 \mathcal{R} \arcsin \left(\sqrt{\sin^2(\lambda / 2 )}\right)
\]</span> <span id="eq-d-0"><span class="math display">\[
d = 2 \mathcal{R} \arcsin \left(\sqrt{ \text{hav}(\lambda) }\right)
\tag{1}\]</span></span> Where <span class="math inline">\(h\)</span> is the <strong>Haversine function</strong> given by: <span id="eq-hav-0"><span class="math display">\[
\text{hav}(\lambda) := \sin^2\left(\frac{\lambda}{2}\right) = \frac{1 - \cos(\lambda)}{2}~.
\tag{2}\]</span></span></p>
<p>The haversine function is particularly handy when we want to avoid computing a <span class="math inline">\(\cos\)</span>, and to transform it into a <span class="math inline">\(\sin\)</span> function. Since the <span class="math inline">\(\cos\)</span> for small angle is numerically unstable, given a <span class="math inline">\(\lambda\)</span> we can chose if we want to compute <span class="math inline">\(\text{hav}{\lambda}\)</span> via the <span class="math inline">\(\sin\)</span> or the <span class="math inline">\(\cos\)</span> according to the numerical stability we want to obtain.</p>
<p>From <a href="#eq-d-0" class="quarto-xref">Equation&nbsp;1</a> with the definition of the haversine function and some derivations detailed afterwards, we can get: <span id="eq-hav-dist-1"><span class="math display">\[
d = 2 \mathcal{R} \arcsin
\left(
    \left[  
        \text{hav}(\varphi_B - \varphi_A) + \cos\varphi_A \cos\varphi_B ~\text{hav}(\theta_B - \theta_A)
    \right]^{1/2}
\right) \\
\tag{3}\]</span></span> And equivalently <span id="eq-hav-dist-2"><span class="math display">\[
d = 2 \mathcal{R} \arcsin
\left(
    \left[  
        \text{hav}(\varphi_B - \varphi_A) + (1 - \text{hav}(\varphi_B - \varphi_A) - \text{hav}(\varphi_B + \varphi_A) ) \text{hav}(\theta_B - \theta_A)
    \right]^{1/2}
\right)
\tag{4}\]</span></span></p>
<p>Where the last two equations are a consequence of the following ones, that are still to be proven: <span id="eq-hav-1"><span class="math display">\[
\text{hav}(\lambda) =
        \text{hav}(\varphi_B - \varphi_A) + \cos\varphi_A \cos\varphi_B ~\text{hav}(\theta_B - \theta_A)
\tag{5}\]</span></span> and <span id="eq-hav-2"><span class="math display">\[
\text{hav}(\lambda) =
        \text{hav}(\varphi_B - \varphi_A) + (1 - \text{hav}(\varphi_B - \varphi_A) - \text{hav}(\varphi_B + \varphi_A) ) \text{hav}(\theta_B - \theta_A)
\tag{6}\]</span></span></p>
<section id="proof-of-eq-hav-1" class="level4">
<h4 class="anchored" data-anchor-id="proof-of-eq-hav-1">Proof of <a href="#eq-hav-1" class="quarto-xref">Equation&nbsp;5</a></h4>
<p><strong>Hypothesis:</strong> <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> points on the surface of a sphere, with coordinates</p>
<p><span class="math inline">\(A=(\theta_A, \varphi_A) = (\cos\theta_A~\cos\varphi_A, \sin\theta_A~\cos\varphi_A, \sin\varphi_A )\)</span> and</p>
<p><span class="math inline">\(B=(\theta_B, \varphi_B) = (\cos\theta_B~\cos\varphi_B, \sin\theta_B~\cos\varphi_B, \sin\varphi_B )\)</span></p>
<p>and <span class="math inline">\(\lambda\)</span> angle at the centre of the sphere.</p>
<p><strong>Thesis:</strong> <span class="math inline">\(\text{hav}(\lambda) = \text{hav}(\varphi_B - \varphi_A) + \cos\varphi_A \cos\varphi_B ~\text{hav}(\theta_B - \theta_A)\)</span>.</p>
<p>It is always possible to rotate the axis so to have <span class="math inline">\(\theta_A = 0\)</span>, and <span class="math inline">\(\tilde{\theta}_B = \theta_B - \theta_A\)</span>. In the new coordinate system we have: <span class="math display">\[
\begin{align*}
A &amp;= (\cos\varphi_A, 0, \sin\varphi_A ) \\
B &amp;=(\cos\tilde{\theta}_B~\cos\varphi_B, \sin\tilde{\theta}_B~\cos\varphi_B, \sin\varphi_B )
\end{align*}
\]</span></p>
<p>Now, how do we connect the angle <span class="math inline">\(\lambda\)</span> with <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>?</p>
<p>With the scalar product, of course!</p>
<p>Then we can add and subtract a ghost term and apply the addition subtraction formulae: <span class="math display">\[
\begin{align*}
\cos\lambda &amp;= A \cdot B \\
&amp;= \cos\varphi_A~\cos\tilde{\theta}_B~\cos\varphi_B + \sin\varphi_A~\sin\varphi_B \\
&amp;= \cos\varphi_A~\cos\tilde{\theta}_B~\cos\varphi_B + \sin\varphi_A~\sin\varphi_B + \cos\varphi_A~\cos\varphi_B -  \cos\varphi_A~\cos\varphi_B \\
&amp;= \cos\varphi_A~\cos\varphi_B(\cos\tilde{\theta}_B - 1) + \cos(\varphi_A - \varphi_B)
\end{align*}
\]</span> With simple algebraic manipulations the previous equation becomes: <span class="math display">\[
\begin{align*}
\frac{1 - \cos\lambda}{2}
= \frac{1 - \cos(\varphi_A - \varphi_B)}{2} - \frac{1}{2}  \cos\varphi_A~\cos\varphi_B(\cos\tilde{\theta}_B - 1)
\end{align*}
\]</span> and considering that for any angle <span class="math inline">\(\alpha\)</span> we have <span class="math inline">\(\cos(\alpha) = \cos(-\alpha)\)</span>, the previous equation is equivalent to the sought thesis: <span class="math display">\[
\text{hav}(\lambda) = \text{hav}(\varphi_B - \varphi_A) + \cos\varphi_A \cos\varphi_B ~\text{hav}(\theta_B - \theta_A)
\]</span></p>
</section>
<section id="proof-of-eq-hav-2" class="level4">
<h4 class="anchored" data-anchor-id="proof-of-eq-hav-2">Proof of <a href="#eq-hav-2" class="quarto-xref">Equation&nbsp;6</a></h4>
<p>Under the hypothesis of the previous proof, the <strong>thesis</strong> reduces to <span class="math inline">\(\cos\varphi_A \cos\varphi_B = 1 - \text{hav}(\varphi_B - \varphi_A) - \text{hav}(\varphi_B + \varphi_A)\)</span>.</p>
<p>The proof starts and end as a direct consequence of the <a href="https://en.wikibooks.org/wiki/Trigonometry/Addition_Formula_for_Cosines">addition subtraction formulae</a>: <span class="math display">\[
\begin{align*}
\cos\varphi_A \cos\varphi_B
&amp;= \frac{1}{2}\left(  \cos(\varphi_B - \varphi_A) + \cos(\varphi_B + \varphi_A) \right) \\
&amp;= 1 - \frac{1}{2} - \frac{1}{2} + \frac{\cos(\varphi_B - \varphi_A)}{2} + \frac{\cos(\varphi_B + \varphi_A)}{2} \\
&amp;= 1  - \frac{ 1 - \cos(\varphi_B - \varphi_A)}{2} - \frac{1 - \cos(\varphi_B + \varphi_A)}{2} \\
&amp;= 1  - \text{hav}(\varphi_B - \varphi_A) - \text{hav}(\varphi_B + \varphi_A) \\
\end{align*}
\]</span> which concludes the proof of the Haversine formula.</p>
</section>
</section>
<section id="sec-implementation" class="level2">
<h2 class="anchored" data-anchor-id="sec-implementation">Implementation and examples</h2>
<p>From a computational point of view, as sadi before, we want to avoid computing <span class="math inline">\(\sin\)</span> when the angles are very small. So a stable implementation would use the last part of <a href="#eq-hav-0" class="quarto-xref">Equation&nbsp;2</a>.</p>
<div id="cell-17" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">""" Haversine function in python"""</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hav_function_sin(theta_A, phi_A, theta_B, phi_B):</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># haversine computed with the sin</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    hav_rad <span class="op">=</span> <span class="kw">lambda</span>  x: np.sin(x<span class="op">/</span><span class="dv">2</span>) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hav_rad(phi_B <span class="op">-</span> phi_A) <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> hav_rad(phi_B <span class="op">-</span> phi_A) <span class="op">-</span> hav_rad(phi_B <span class="op">+</span> phi_A) ) <span class="op">*</span> hav_rad(theta_B <span class="op">-</span> theta_A)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> haversine_distance_sin(lon_1, lat_1, lon_2, lat_2):</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    theta_1, phi_1, theta_2, phi_2 <span class="op">=</span> <span class="bu">map</span>(np.radians, [lon_1, lat_1, lon_2, lat_2])</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">2</span> <span class="op">*</span> R_Km <span class="op">*</span> np.arcsin(np.sqrt(hav_function_sin(theta_1, phi_1, theta_2, phi_2)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-18" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify that it looks correct:</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>PREC <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Distance London to London = </span><span class="sc">{</span><span class="bu">round</span>(haversine_distance_sin(<span class="op">*</span>lon_lat_london, <span class="op">*</span>lon_lat_london), PREC)<span class="sc">}</span><span class="ss"> Km"</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Distance London to Paris  = </span><span class="sc">{</span><span class="bu">round</span>(haversine_distance_sin(<span class="op">*</span>lon_lat_london, <span class="op">*</span>lon_lat_paris), PREC)<span class="sc">}</span><span class="ss"> Km"</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Distance Paris to London  = </span><span class="sc">{</span><span class="bu">round</span>(haversine_distance_sin(<span class="op">*</span>lon_lat_paris, <span class="op">*</span>lon_lat_london), PREC)<span class="sc">}</span><span class="ss"> Km"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Distance London to London = 0.0 Km
Distance London to Paris  = 334.563443 Km
Distance Paris to London  = 334.563443 Km</code></pre>
</div>
</div>
<p>It seems to be working correctly. Let’s compare it with an out of the box function from the library <code>sklearn</code> (see also this <a href="https://stackoverflow.com/questions/4913349/haversine-formula-in-python-bearing-and-distance-between-two-gps-points">stack overflow discussion</a> and <a href="https://stackoverflow.com/questions/19412462/getting-distance-between-two-points-based-on-latitude-longitude">this one</a>)</p>
<div id="cell-20" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics.pairwise <span class="im">import</span> haversine_distances <span class="im">as</span> haversine_distances_sklearn</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>lon_A, lat_A <span class="op">=</span> lon_lat_london</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>lon_B, lat_B <span class="op">=</span> lon_lat_paris</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>vals <span class="op">=</span> [[np.radians(lat_A), np.radians(lon_A)], [np.radians(lat_B), np.radians(lon_B)]]</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>distance_sklearn <span class="op">=</span> R_Km <span class="op">*</span> haversine_distances_sklearn(vals)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Distance London to Paris for sklearn  = </span><span class="sc">{</span><span class="bu">round</span>(distance_sklearn[<span class="dv">1</span>,<span class="dv">0</span>], PREC)<span class="sc">}</span><span class="ss"> Km"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Distance London to Paris for sklearn  = 334.563443 Km</code></pre>
</div>
</div>
</section>
<section id="sec-numerical-stability" class="level2">
<h2 class="anchored" data-anchor-id="sec-numerical-stability">Numerical stability</h2>
<p>Let’s see what happens in term of numerical stability. We take now two points in london very close to each others:</p>
<div id="cell-22" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>lon_lat_london_1 <span class="op">=</span> (<span class="fl">0.1276</span>, <span class="fl">51.5072</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>lon_lat_london_2 <span class="op">=</span> (<span class="fl">0.1276</span>, <span class="fl">51.50720001</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>PREC <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Very small distance (hav with sin) = </span><span class="sc">{</span><span class="bu">round</span>(haversine_distance_sin(<span class="op">*</span>lon_lat_london_1, <span class="op">*</span>lon_lat_london_2), PREC)<span class="sc">}</span><span class="ss"> Km"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Very small distance (hav with sin) = 1.11194938401393e-06 Km</code></pre>
</div>
</div>
<p>We can see that our implementation with the haversine function, computed with the <code>sin</code> version, does not collapse to zero.</p>
<p>What happens if we re-implement with function with the cosine?</p>
<div id="cell-24" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># repeated code with a small change. Now the Haversine function is computed with the cosine</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hav_function_cos(theta_A, phi_A, theta_B, phi_B):</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Haversine computed with the cosine - Numerically unstable!</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    hav_rad <span class="op">=</span> <span class="kw">lambda</span>  x: (<span class="dv">1</span><span class="op">-</span>np.cos(x))<span class="op">/</span><span class="dv">2</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hav_rad(phi_B <span class="op">-</span> phi_A) <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> hav_rad(phi_B <span class="op">-</span> phi_A) <span class="op">-</span> hav_rad(phi_B <span class="op">+</span> phi_A) ) <span class="op">*</span> hav_rad(theta_B <span class="op">-</span> theta_A)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> haversine_distance_cos(lon_1, lat_1, lon_2, lat_2):</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    theta_1, phi_1, theta_2, phi_2 <span class="op">=</span> <span class="bu">map</span>(np.radians, [lon_1, lat_1, lon_2, lat_2])</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">2</span> <span class="op">*</span> R_Km <span class="op">*</span> np.arcsin(np.sqrt(hav_function_cos(theta_1, phi_1, theta_2, phi_2)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-25" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Distance London to Paris (hav with cos) = </span><span class="sc">{</span><span class="bu">round</span>(haversine_distance_cos(<span class="op">*</span>lon_lat_london, <span class="op">*</span>lon_lat_paris), PREC)<span class="sc">}</span><span class="ss"> Km"</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Very small distance (hav with cos)      = </span><span class="sc">{</span><span class="bu">round</span>(haversine_distance_cos(<span class="op">*</span>lon_lat_london_1, <span class="op">*</span>lon_lat_london_2), PREC)<span class="sc">}</span><span class="ss"> Km"</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Very small distance (hav with sin)      = </span><span class="sc">{</span><span class="bu">round</span>(haversine_distance_sin(<span class="op">*</span>lon_lat_london_1, <span class="op">*</span>lon_lat_london_2), PREC)<span class="sc">}</span><span class="ss"> Km"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Distance London to Paris (hav with cos) = 334.5634431209046 Km
Very small distance (hav with cos)      = 0.0 Km
Very small distance (hav with sin)      = 1.11194938401393e-06 Km</code></pre>
</div>
</div>
<p>The function works well for large angles, though for small angle the Haversine distance computed with the cosine collapses.</p>
<p>Had the developers of <code>sklearn</code> use the <code>sin</code> or the <code>cos</code>?</p>
<div id="cell-27" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>lon_A, lat_A <span class="op">=</span> lon_lat_london_1</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>lon_B, lat_B <span class="op">=</span> lon_lat_london_2</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>vals <span class="op">=</span> [[np.radians(lat_A), np.radians(lon_A)], [np.radians(lat_B), np.radians(lon_B)]]</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>dist_sklearn <span class="op">=</span> R_Km <span class="op">*</span> haversine_distances_sklearn(vals)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>PREC <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Very small distance for sklearn  = </span><span class="sc">{</span><span class="bu">round</span>(dist_sklearn[<span class="dv">1</span>,<span class="dv">0</span>], PREC)<span class="sc">}</span><span class="ss"> Km"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Very small distance for sklearn  = 1.11194938401393e-06 Km</code></pre>
</div>
</div>
<p>We can see that (at least for this case) our results and the <code>sklearn</code> implementation are the same! And we may even daring to assume that <code>sklearn</code> implemented the haversine distance with the <code>sin</code> formula.</p>
</section>
<section id="sec-vincentry-formula" class="level2">
<h2 class="anchored" data-anchor-id="sec-vincentry-formula">See also: Vincenty’s formula</h2>
<p>To compute the distance between two points on an ellipsoid model (which is more accurate than the spherical model on which the Haversine is based on) there is the Vincenty formula <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p>Its mathematical derivation may be the topic for another post, though if you want to have it computed with a tool out of the box, we recommend the library <code>geopy</code>.</p>
<div id="cell-30" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> geopy <span class="im">import</span> distance</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>lon_A, lat_A <span class="op">=</span> lon_lat_london</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>lon_B, lat_B <span class="op">=</span> lon_lat_paris</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>vals <span class="op">=</span> [[np.radians(lat_A), np.radians(lon_A)], [np.radians(lat_B), np.radians(lon_B)]]</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>dist_sklearn <span class="op">=</span> R_Km <span class="op">*</span> haversine_distances_sklearn(vals)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>dist_vincenty <span class="op">=</span> distance.distance(lon_lat_london[::<span class="op">-</span><span class="dv">1</span>], lon_lat_paris[::<span class="op">-</span><span class="dv">1</span>]).km</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>PREC <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Distance with haversine (sklearn) =  </span><span class="sc">{</span><span class="bu">round</span>(dist_sklearn[<span class="dv">1</span>,<span class="dv">0</span>], PREC)<span class="sc">}</span><span class="ss"> Km"</span>)</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Distance with Vincenty (geopy)    =  </span><span class="sc">{</span><span class="bu">round</span>(dist_vincenty, PREC)<span class="sc">}</span><span class="ss"> Km"</span>)</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Relative error = |ground - calculated|/|ground| = </span><span class="sc">{</span><span class="bu">round</span>(<span class="dv">100</span> <span class="op">*</span> <span class="bu">abs</span>(dist_vincenty <span class="op">-</span> dist_sklearn[<span class="dv">1</span>,<span class="dv">0</span>]) <span class="op">/</span> dist_vincenty, PREC)<span class="sc">}</span><span class="ss"> %"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Distance with haversine (sklearn) =  334.563443 Km
Distance with Vincenty (geopy)    =  334.883889 Km
Relative error = |ground - calculated|/|ground| = 0.095689 %</code></pre>
</div>
</div>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>See for example by JP Snyder · 1987 <a href="https://pubs.usgs.gov/publication/pp1395">“Map projections: A working manual”</a>, U.S. Government Printing Office, or H.S. Roblin “Map projections”, Edward Arnold Publisher Ltd.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>The original Vincenty’s paper by can be found <a href="https://www.ngs.noaa.gov/wp-content/uploads/2018/12/inverse.pdf">here</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/sebastianof\.github\.io\/GeoDsBlog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Blog made with <a href="https://quarto.org/">Quarto</a>, by Sebastiano Ferraris. License: <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC BY-SA 2.0</a>.</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/sebastianof/">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="mailto:sebastiano.ferraris@gmail.com">
      <i class="bi bi-envelope" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>