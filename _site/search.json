[
  {
    "objectID": "posts/index_gds.html",
    "href": "posts/index_gds.html",
    "title": "Geospatial Data Science",
    "section": "",
    "text": "Python datetimes manipulations\n\n\nCode fragments for timestamps and timezones manipulation\n\n\n\n\n\nJan 24, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nHaversine’s distance mathematics\n\n\nComputing the distance between two points on a sphere\n\n\n\n\n\nJan 13, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nUsing polygons\n\n\nGeospatial data science basic operations and measurements\n\n\n\n\n\nOct 3, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nHow well positioned is your office?\n\n\nTime to question your workplace location\n\n\n\n\n\nJul 29, 2022\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/gds-2024-01-24-timestamp/index.html#summary",
    "href": "posts/gds-2024-01-24-timestamp/index.html#summary",
    "title": "Python datetimes manipulations",
    "section": "Summary",
    "text": "Summary\nThis blog post collects in one place a range of methods for converting datetime objects across types in python and pandas.\nThe code snippet and the subsequent diagram summarise the data casting between datetime, int, str, pd.Timestamp.\nThe remaining sections offer more details and examples about each of those methods. At the end of the post you will find a section about some snippets to manipulate timezones in all the examined formats.\n\nimport datetime as dt\nimport pandas as pd\n\n# create a datetime\ndt_event = dt.datetime(year=2024, month=1, day=22, hour=13, minute=55, second=12)\n\n# convert to string with specific format code\nFORMAT_CODE = \"%m/%d/%Y, %H:%M:%S\"\ndt_event_str = dt_event.strftime(FORMAT_CODE)\n\n# convert from string to datetime\ndt_event = dt.datetime.strptime(dt_event_str, FORMAT_CODE)\n\n# convert from datetime to integer (milliseconds)\nmsec_event = int(dt_event.timestamp() * 1000)\n\n# convert from milliseconds to integer\ndt_event = dt.datetime.fromtimestamp(msec_event / 1000)\n\n# create a list of timestamps\ndt_start, dt_end = dt.datetime(2022, 3, 1), dt.datetime(2022, 3, 10)\n \nlist_events = []\n\nwhile dt_start &lt;= dt_end:\n    list_events.append(dt_start)\n    dt_start += dt.timedelta(days=1)\n\n# convert list of timestamps to pandas DatetimeIdex of pd.Timestamps\nindex_events = pd.to_datetime(list_events)\n\n# convert pandas DatetimeIdex of pd.Timestamps to list of timestamps\nlist_events = [dt.datetime.combine(x.date(), x.time()) for x in index_events]\n\n\n# convert pandas DatetimeIdex of pd.Timestamps to an Index of integers (nanoseconds)\nindex_events_int = index_events.astype(int)\n\n# convert pandas Index of integers (nanoseconds) to DatetimeIdex of pd.Timestamps\nindex_events = pd.to_datetime(index_events_int)\n\n# convert pandas DatetimeIdex of pd.Timestamps to an Index of strings\nindex_events_str = index_events.astype(str)\n\n# convert pandas Index of strings to DatetimeIdex of pd.Timestamps\nindex_events = pd.to_datetime(index_events_str)"
  },
  {
    "objectID": "posts/gds-2024-01-24-timestamp/index.html#introduction",
    "href": "posts/gds-2024-01-24-timestamp/index.html#introduction",
    "title": "Python datetimes manipulations",
    "section": "Introduction",
    "text": "Introduction\nWhen first started working with time series, a recurrent task was for me to google up ways to convert datetimes across python and pandas data types. It took me some times to get to have a grasp about the possibilities and conversion methods, as well as how to set and change timezones without making mistakes.\nThis blog post is for you to get the same information I got browsing for a while around various stackoverflows and documentation pages, all in one place.\nAs it is for manipulations of polygons, handling datetimes is another recurring task in geospatial data science.\nIn python there are multiple ways to encode a point in time according to a range of criteria:\n\nReadability\nStoring space\nOut of the box methods\n\nBefore delving into some examples, let’s warm up with a code snippet showing what can go wrong if dates and times are manipulated carelessly.\n\nimport datetime as dt\n\nFORMAT = \"%H:%M:%S%z %Y-%m-%d\"\n\nevent_1 = dt.datetime.strptime(\"22:15:00+00:00 2022-05-01\", FORMAT)\nevent_2 = dt.datetime.strptime(\"18:30:00+00:00 2022-06-01\", FORMAT)\n\nprint(f\"Events as type {type(event_1)}\")\nprint(f\"Event 1: {event_1}\")\nprint(f\"Event 2: {event_2}\")\n\nif event_1 &lt; event_2: \n    print(f\"\\nDatetime {event_1} comes before {event_2}\")\n\n\nevent_1 = event_1.strftime(FORMAT)\nevent_2 = event_2.strftime(FORMAT)\n\nprint(f\"\\nEvents as type {type(event_1)}\")\nprint(f\"Event 1: {event_1}\")\nprint(f\"Event 2: {event_2}\")\n\n\nif event_1 &gt; event_2: \n    print(f\"\\nDatetime {event_1} comes after {event_2}.\")\n    print(\"Oh, Really?\")\n\nEvents as type &lt;class 'datetime.datetime'&gt;\nEvent 1: 2022-05-01 22:15:00+00:00\nEvent 2: 2022-06-01 18:30:00+00:00\n\nDatetime 2022-05-01 22:15:00+00:00 comes before 2022-06-01 18:30:00+00:00\n\nEvents as type &lt;class 'str'&gt;\nEvent 1: 22:15:00+0000 2022-05-01\nEvent 2: 18:30:00+0000 2022-06-01\n\nDatetime 22:15:00+0000 2022-05-01 comes after 18:30:00+0000 2022-06-01.\nOh, Really?\n\n\nCan you see what went wrong?\nIn this example we started from two datetimes (any representation of a date and a time) in string format. These were converted to instances of datetime.datetime from the standard library datetime.\nThe first odd thing, that becomes evident when calling type(dt.datetime.strptime(\"22:15:00+00:00 2022-05-01\", FORMAT)) is that datetime.datetime is not a class. It is a type, like int and str, so it does not follow the camel case convention1.\nAlso that the type name and the library name are the same. So, in some modules you will find from datetime import datetime and in other simply import datetime, a confusion that I avoid usually aliasing the library datetime to dt, as done in the previous example.\nFrom the diagram shown, we can see another source of possible confusions: in the python world the term timestamp refers to a datetime object converted to an integer — more details in the section later about how this is done. In the pandas world instead, the term timestamp is used as the class that encodes the pandas datetime object. So there is a change in the naming convention if you are using the python standards libraries, or if you are using pandas.\nStarting from the center of the diagram, in each section of this post we will explore a conversion and the specifications of the given types, leaving pandas.Timestamp for last."
  },
  {
    "objectID": "posts/gds-2024-01-24-timestamp/index.html#datetime.datetime-to-str-and-back",
    "href": "posts/gds-2024-01-24-timestamp/index.html#datetime.datetime-to-str-and-back",
    "title": "Python datetimes manipulations",
    "section": "datetime.datetime to str and back",
    "text": "datetime.datetime to str and back\nThere are many formats to represent a datetime into a string. One of the standard is specified in ISO8601.\n\n# create a datetime - you need at least year, month and day.\ndt_event = dt.datetime(year=2024, month=1, day=22)\ndt_event\n\ndatetime.datetime(2024, 1, 22, 0, 0)\n\n\n\n# create a datetime with hour, minutes and seconds\ndt_event = dt.datetime(year=2024, month=1, day=22, hour=13, minute=55, second=12)\ndt_event\n\ndatetime.datetime(2024, 1, 22, 13, 55, 12)\n\n\n\n# convert to string with a range of formats\nprint(dt_event.strftime(\"%m/%d/%Y, %H:%M:%S\"))\nprint(dt_event.strftime(\"%Y-%m-%d, %H:%M\"))\nprint(dt_event.strftime(\"%H:%M\"))\n\n01/22/2024, 13:55:12\n2024-01-22, 13:55\n13:55\n\n\nOnce we have the string we can move back to the timestamp object, passing the same format code (this operation is not bijective if some of the information is not included in the chosen format code).\nMore info about the format codes and what each letter means is available at the official documentation https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior.\n\n# Create a datetime object\ndt_event = dt.datetime(year=2024, month=1, day=22, hour=13, minute=55, second=12, microsecond=120)\nprint(f\"Datetime: {dt_event}\")\n\n# convert to string\nFORMAT_CODE = \"%m/%d/%Y, %H:%M:%S\"\nstr_event = dt_event.strftime(FORMAT_CODE)\nprint(f\"String:   {dt_event}\")\n\n# string to datetime\nprint(f\"Datetime: {dt.datetime.strptime(str_event, FORMAT_CODE)}\")\n\nDatetime: 2024-01-22 13:55:12.000120\nString:   2024-01-22 13:55:12.000120\nDatetime: 2024-01-22 13:55:12\n\n\nIn addition to timestamp.timestamp you can create only the time, the date and a timedelta.\n\nprint(dt.time(hour=4))\nprint(dt.date(year=2024, month=3, day=11))\nprint(dt.timedelta(hours=3))  \n\n# we can not sum a timedelta to a time\ntry:\n    print(dt.time(hour=4) + dt.time(hour=4))\nexcept TypeError as err:\n    print(f\"Error raised: TypeError {err}\")\n\n# nor to a date\ntry:\n    print(dt.date(year=2024, month=3, day=11) + dt.time(hour=4))\nexcept TypeError as err:\n    print(f\"Error raised: TypeError {err}\")\n\n# but we can sum it to a timestamp\nprint(dt.datetime(year=2024, month=3, day=11, hour=3) + dt.timedelta(hours=4))\n\n04:00:00\n2024-03-11\n3:00:00\nError raised: TypeError unsupported operand type(s) for +: 'datetime.time' and 'datetime.time'\nError raised: TypeError unsupported operand type(s) for +: 'datetime.date' and 'datetime.time'\n2024-03-11 07:00:00\n\n\n\n# if we quickly want to have the timestamp converted to a string in isoformat we can use:\ndt_event.isoformat()\n\n'2024-01-22T13:55:12.000120'"
  },
  {
    "objectID": "posts/gds-2024-01-24-timestamp/index.html#datetime.datetime-to-int-and-back",
    "href": "posts/gds-2024-01-24-timestamp/index.html#datetime.datetime-to-int-and-back",
    "title": "Python datetimes manipulations",
    "section": "datetime.datetime to int and back",
    "text": "datetime.datetime to int and back\nThe integer representation of a datetime is called timestamp in the python world. We note again that it is not the same as the the pandas Timestamp object.\nA timestamp is a numerical representation of a date in the Unix epoch (or Unix time or POSIX time or Unix timestamp). It is the number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT), not counting leap seconds (using the ISO 8601 convention it is 1970-01-01T00:00:00Z).\n\ndt_event = dt.datetime(year=2024, month=3, day=11, hour=3)\ndt_event.timestamp?\n\nDocstring: Return POSIX timestamp as float.\nType:      builtin_function_or_method\n\n\nOut of the box, the python timestamp is in seconds, and encoded as a float. In some dataset, and to save memory, it can be encoded in milliseconds or even in microseconds, and encoded as an integer.\n\nprint(f\"Datetime:         {dt_event}\")\nprint(f\"Python timestamp: {dt_event.timestamp()}\")\n\nDatetime:         2024-03-11 03:00:00\nPython timestamp: 1710126000.0\n\n\n\nISO_FORMAT_CODE = \"%Y-%m-%dT%H:%M:%S%z\"\ndt_event_zero = dt.datetime.strptime(\"1970-01-01T00:00:00Z\", ISO_FORMAT_CODE)\nprint(f\"Datetime:         {dt_event_zero}\")\nprint(f\"Python timestamp: {dt_event_zero.timestamp()}\")\n\nDatetime:         1970-01-01 00:00:00+00:00\nPython timestamp: 0.0\n\n\n\ndt_event = dt.datetime(year=2024, month=3, day=11, hour=3, minute=13, second=45)\nsec_event = int(dt_event.timestamp())\nmsec_event = int(dt_event.timestamp() * 1000)  # convert to milliseconds before casting\nback_to_dt_event = dt.datetime.fromtimestamp(msec_event / 1000)\n\nprint(f\"Datetime:              {dt_event}\")\nprint(f\"Python timestamp (s):  {sec_event}\")\nprint(f\"Python timestamp (ms): {msec_event}\")\nprint(f\"Back to datetime:      {back_to_dt_event}\")\n\nDatetime:              2024-03-11 03:13:45\nPython timestamp (s):  1710126825\nPython timestamp (ms): 1710126825000\nBack to datetime:      2024-03-11 03:13:45"
  },
  {
    "objectID": "posts/gds-2024-01-24-timestamp/index.html#datetime.datetime-str-and-int-to-pandas.timestamp-and-back",
    "href": "posts/gds-2024-01-24-timestamp/index.html#datetime.datetime-str-and-int-to-pandas.timestamp-and-back",
    "title": "Python datetimes manipulations",
    "section": "datetime.datetime, str and int to pandas.Timestamp and back",
    "text": "datetime.datetime, str and int to pandas.Timestamp and back\nIn pandas we typically don’t deal with a single datetime, but with a list of those. With timeseries, pandas becomes particularly efficient when timeseries are used as data frames indexes.\nHere we see some examples of conversion of lists of datetime.datetime into pandas pd.Timestamp indexes, and into int and string.\n\ndef print_events(iterable_events):\n    \"\"\"helper to print info about iterable events len and types\"\"\"\n    print(f\"{len(iterable_events)} days: \")\n    print(\"[\")\n    for ev in iterable_events:\n        print(f\"    {ev}\")\n    print(\"]\")\n    print(f\"This is a {type(iterable_events)} of {type(iterable_events[0])} elements.\")\n\n\n# Create a list of datetime.datetime\ndt_start = dt.datetime(2022, 3, 1)\ndt_end = dt.datetime(2022, 3, 10)\n \nlist_events = []\n \nwhile dt_start &lt;= dt_end:\n    list_events.append(dt_start)\n    dt_start += dt.timedelta(days=1)\n\nprint_events(list_events)\n\n10 days: \n[\n    2022-03-01 00:00:00\n    2022-03-02 00:00:00\n    2022-03-03 00:00:00\n    2022-03-04 00:00:00\n    2022-03-05 00:00:00\n    2022-03-06 00:00:00\n    2022-03-07 00:00:00\n    2022-03-08 00:00:00\n    2022-03-09 00:00:00\n    2022-03-10 00:00:00\n]\nThis is a &lt;class 'list'&gt; of &lt;class 'datetime.datetime'&gt; elements.\n\n\n\n# Create the same list as above, with pandas.date_range https://pandas.pydata.org/docs/reference/api/pandas.date_range.html\nimport pandas as pd\nimport numpy as np\n\ndt_start = dt.datetime(2022, 3, 1)\ndt_end = dt.datetime(2022, 3, 10)\n \nindex_events = pd.date_range(start=dt_start, end=dt_end)\n\nprint_events(index_events)\n\n10 days: \n[\n    2022-03-01 00:00:00\n    2022-03-02 00:00:00\n    2022-03-03 00:00:00\n    2022-03-04 00:00:00\n    2022-03-05 00:00:00\n    2022-03-06 00:00:00\n    2022-03-07 00:00:00\n    2022-03-08 00:00:00\n    2022-03-09 00:00:00\n    2022-03-10 00:00:00\n]\nThis is a &lt;class 'pandas.core.indexes.datetimes.DatetimeIndex'&gt; of &lt;class 'pandas._libs.tslibs.timestamps.Timestamp'&gt; elements.\n\n\n\n# Assign the index to a dataframe\nimport numpy as np\ndf = pd.DataFrame(np.random.choice(list(\"random\"), size=len(index_events))).set_index(index_events)\ndf\n\n\n\n\n\n\n\n\n0\n\n\n\n\n2022-03-01\nm\n\n\n2022-03-02\nr\n\n\n2022-03-03\nn\n\n\n2022-03-04\no\n\n\n2022-03-05\nr\n\n\n2022-03-06\nd\n\n\n2022-03-07\nm\n\n\n2022-03-08\nn\n\n\n2022-03-09\na\n\n\n2022-03-10\nd\n\n\n\n\n\n\n\n\n# Same pandas index_events created above can be created directly with strings\nindex_events = pd.date_range(start='3/1/2022', end='3/10/2022')\n\nprint_events(index_events)\n\n10 days: \n[\n    2022-03-01 00:00:00\n    2022-03-02 00:00:00\n    2022-03-03 00:00:00\n    2022-03-04 00:00:00\n    2022-03-05 00:00:00\n    2022-03-06 00:00:00\n    2022-03-07 00:00:00\n    2022-03-08 00:00:00\n    2022-03-09 00:00:00\n    2022-03-10 00:00:00\n]\nThis is a &lt;class 'pandas.core.indexes.datetimes.DatetimeIndex'&gt; of &lt;class 'pandas._libs.tslibs.timestamps.Timestamp'&gt; elements.\n\n\n\n# Convert the list of datetimes to the pandas index\nindex_events_converted = pd.to_datetime(list_events)\n\nprint_events(index_events)\n\nif not pd.testing.assert_index_equal(index_events_converted, index_events):\n    print()\n    print(\"The two index events are not considered equal! Why?\")\n\n10 days: \n[\n    2022-03-01 00:00:00\n    2022-03-02 00:00:00\n    2022-03-03 00:00:00\n    2022-03-04 00:00:00\n    2022-03-05 00:00:00\n    2022-03-06 00:00:00\n    2022-03-07 00:00:00\n    2022-03-08 00:00:00\n    2022-03-09 00:00:00\n    2022-03-10 00:00:00\n]\nThis is a &lt;class 'pandas.core.indexes.datetimes.DatetimeIndex'&gt; of &lt;class 'pandas._libs.tslibs.timestamps.Timestamp'&gt; elements.\n\nThe two index events are not considered equal! Why?\n\n\nHere something interesting have happened. Even if the two series have the same values, they are not equal.\nPrinting them individually will show why:\n\nindex_events\n\nDatetimeIndex(['2022-03-01', '2022-03-02', '2022-03-03', '2022-03-04',\n               '2022-03-05', '2022-03-06', '2022-03-07', '2022-03-08',\n               '2022-03-09', '2022-03-10'],\n              dtype='datetime64[ns]', freq='D')\n\n\n\nindex_events_converted\n\nDatetimeIndex(['2022-03-01', '2022-03-02', '2022-03-03', '2022-03-04',\n               '2022-03-05', '2022-03-06', '2022-03-07', '2022-03-08',\n               '2022-03-09', '2022-03-10'],\n              dtype='datetime64[ns]', freq=None)\n\n\nThe freq= value of the converted frequency is different from the frequency of the original one, that is defined by days. Under the hood they are different objects, as the first one contains first and last element and the frequency, and the second contains every single individual element.\nEven assigning the frequency to index_events_converted afterwards does not make the two DateteimeIndex equal:\n\nindex_events_converted.freq = \"D\"\nindex_events_converted\n\nDatetimeIndex(['2022-03-01', '2022-03-02', '2022-03-03', '2022-03-04',\n               '2022-03-05', '2022-03-06', '2022-03-07', '2022-03-08',\n               '2022-03-09', '2022-03-10'],\n              dtype='datetime64[ns]', freq='D')\n\n\n\nif not pd.testing.assert_index_equal(index_events_converted, index_events):\n    print()\n    print(\"The two index events are still not equal!\")\n\n\nThe two index events are still not equal!\n\n\nWhen working with pd.Timestamp we have to keep in mind that different constructors creating the same numerical results produce different objects.\nWhat about the memory? Also this is the same for both objects:\n\nprint(index_events.memory_usage())\nprint(index_events_converted.memory_usage())\n\n80\n80\n\n\nNow we can convert back from a pandas DatetimeIndex to a list of datetime.datetime objects.\nA pd.Timestamp object can not be converted directly into a datetime.datetime object, but it can be converted into a datetime.date and a datetime.time object.\nSo we can use a list comprehension and combine the two exported formats:\n\n# Create a Pandas Timestamp object\npd_event = pd.Timestamp('2022-06-18 12:34:56')\n\n# Convert the Timestamp to a Python datetime.date object\ndate = pd_event.date()\ntime = pd_event.time()\ndt_event = dt.datetime.combine(date, time)\n\nprint(f\"Event {pd_event} of type {type(pd_event)}\")\nprint(f\"Event {dt_event} of type {type(dt_event)}\")\n\nEvent 2022-06-18 12:34:56 of type &lt;class 'pandas._libs.tslibs.timestamps.Timestamp'&gt;\nEvent 2022-06-18 12:34:56 of type &lt;class 'datetime.datetime'&gt;\n\n\n\nindex_event_converted_back = [dt.datetime.combine(x.date(), x.time()) for x in index_events_converted]\nprint_events(index_event_converted_back)\n\n10 days: \n[\n    2022-03-01 00:00:00\n    2022-03-02 00:00:00\n    2022-03-03 00:00:00\n    2022-03-04 00:00:00\n    2022-03-05 00:00:00\n    2022-03-06 00:00:00\n    2022-03-07 00:00:00\n    2022-03-08 00:00:00\n    2022-03-09 00:00:00\n    2022-03-10 00:00:00\n]\nThis is a &lt;class 'list'&gt; of &lt;class 'datetime.datetime'&gt; elements.\n\n\n\nPandas Timestamp to int\nTo convert a pandas DatetimeIndex from pd.Timestamp to integer, we have to use the .astype method of a pandas series.\n\nprint(index_events)\nindex_events_int = index_events.astype(int)\nprint()\nprint(index_events_int)\n\nDatetimeIndex(['2022-03-01', '2022-03-02', '2022-03-03', '2022-03-04',\n               '2022-03-05', '2022-03-06', '2022-03-07', '2022-03-08',\n               '2022-03-09', '2022-03-10'],\n              dtype='datetime64[ns]', freq='D')\n\nIndex([1646092800000000000, 1646179200000000000, 1646265600000000000,\n       1646352000000000000, 1646438400000000000, 1646524800000000000,\n       1646611200000000000, 1646697600000000000, 1646784000000000000,\n       1646870400000000000],\n      dtype='int64')\n\n\nThe timestamps are now in nanoseconds, as specified in the dtype of the DatetimeIndex index_events. You have to divide it by 1e9 to have them in seconds:\n\nindex_events_int_sec = (index_events_int / 1e9).astype(int)\nindex_events_int_sec\n\nIndex([1646092800, 1646179200, 1646265600, 1646352000, 1646438400, 1646524800,\n       1646611200, 1646697600, 1646784000, 1646870400],\n      dtype='int64')\n\n\n\n# convert back to `DatetimeIndex`\npd.to_datetime(index_events_int)\n\nDatetimeIndex(['2022-03-01', '2022-03-02', '2022-03-03', '2022-03-04',\n               '2022-03-05', '2022-03-06', '2022-03-07', '2022-03-08',\n               '2022-03-09', '2022-03-10'],\n              dtype='datetime64[ns]', freq=None)\n\n\n\n# convert back to `DatetimeIndex`. Pandas expects nanoseconds\npd.to_datetime(index_events_int_sec)\n\nDatetimeIndex(['1970-01-01 00:00:01.646092800',\n               '1970-01-01 00:00:01.646179200',\n               '1970-01-01 00:00:01.646265600',\n                  '1970-01-01 00:00:01.646352',\n               '1970-01-01 00:00:01.646438400',\n               '1970-01-01 00:00:01.646524800',\n               '1970-01-01 00:00:01.646611200',\n               '1970-01-01 00:00:01.646697600',\n                  '1970-01-01 00:00:01.646784',\n               '1970-01-01 00:00:01.646870400'],\n              dtype='datetime64[ns]', freq=None)\n\n\n\n\nPandas Timestamp to str\nConversion to strings works in the same way as with int.\n\n# convert from DatetimeIndex to string.\nprint(index_events)\nindex_events_str = index_events.astype(str)\nprint()\nprint(index_events_str)\n\nDatetimeIndex(['2022-03-01', '2022-03-02', '2022-03-03', '2022-03-04',\n               '2022-03-05', '2022-03-06', '2022-03-07', '2022-03-08',\n               '2022-03-09', '2022-03-10'],\n              dtype='datetime64[ns]', freq='D')\n\nIndex(['2022-03-01', '2022-03-02', '2022-03-03', '2022-03-04', '2022-03-05',\n       '2022-03-06', '2022-03-07', '2022-03-08', '2022-03-09', '2022-03-10'],\n      dtype='object')\n\n\n\n# convert back from string to DatetimeIndex\npd.to_datetime(index_events_str)\n\nDatetimeIndex(['2022-03-01', '2022-03-02', '2022-03-03', '2022-03-04',\n               '2022-03-05', '2022-03-06', '2022-03-07', '2022-03-08',\n               '2022-03-09', '2022-03-10'],\n              dtype='datetime64[ns]', freq=None)"
  },
  {
    "objectID": "posts/gds-2024-01-24-timestamp/index.html#timezones",
    "href": "posts/gds-2024-01-24-timestamp/index.html#timezones",
    "title": "Python datetimes manipulations",
    "section": "Timezones",
    "text": "Timezones\nSome basic concepts first:\n\nUTC universal time coordinates: is the standard to assign to each country in the world a timezone, that is an offset in respect to the timezone zero, also called Zulu or GTM.\nGMT Greenwich Mean Time: is the time zone at the meridian zero, passing at Greenwich in England. The UTC standard tells you how many time zone you are away from Greenwich.\nZulu for the NATO alphabet letter Z, was originally indicating the letter z as in “zero meridian”. This is an equivalent of GTM and it is commonly used in the army and in the civilian aviation. The final “zulu” in a radio message refers to the fact that the time is not read in local time. For example 02:00am at GMT, would read “zero two hundred zulu” in a radio communication.\n\nThe names of the timezones are typically the UTC offsets, written as suffix to the timestamps, such as +02:00 or -05:00, though some particularly recurring timezones have their names, such as:\n\nEastern Standard Time (EST): UTC-0500 or 5 hours behind GMT.\nCentral Standard Time (CST): UTC-0600 or 6 hours behind GMT.\nMountain Standard Time (MST): UTC-0700 or 7 hours behind GMT.\nPacific Standard Time (PST): UTC-0800 or 8 hours behind GMT.\n\n\nTimezones in timestamps\nWhen timezones are written as offsets and appended to the timestamps, the are also summed or subtracted to the datetime itself.\nFor example to write 2023-02-21T06:07:21+03:30 in GMT, we have to set the offset to zero and subtract the offset: 2023-02-21T02:37:21+00:00, that in the ISO 8601 becomes 2023-02-21T02:37:21Z, with in the Zulu timezone, and in a convention that is often found in public datasets as 2023-02-21 02:37:21 UTC, conflating the concepts of GMT and UTC.\nAnother way of encoding the timezones is with the name of a representative city where the timezone belongs to. +03:30 does not tell much about where we are, if compared to \"Asia/Tehran\".\n\n\nNo timezone given\nWhen a timezone is not specified, the timestamp is said to be naive, or not timezone-aware.\nIn this case it is important to check with the data provider if the datetime are given in local time or at GMT. If the datetime are given as integer UNIX timestamps, then they are at GMT, unless there was a mistake in the data ingestion.\n\nimport datetime as dt\nfrom dateutil import tz\n\n# naive\nstr_event = \"2023-02-21 02:37:21\"\n\ndt_event = dt.datetime.strptime(str_event, \"%Y-%m-%d %H:%M:%S\")\nprint(f\"naive datetime:  {dt_event.isoformat()}\")\n\n# GTM\nstr_event = \"2023-02-21 02:37:21 GMT\"  # works also with UTC instead of GMT\n\ndt_event = dt.datetime.strptime(str_event, \"%Y-%m-%d %H:%M:%S %Z\")\nprint(f\"GTM datetime:    {dt_event.isoformat()}\")\n\n# zero offset\nstr_event = \"2023-02-21 02:37:21+00:00\"\n\ndt_event = dt.datetime.strptime(str_event, \"%Y-%m-%d %H:%M:%S%z\")\nprint(f\"datetime +00:00: {dt_event.isoformat()}\")\n\n# +1h offset\nstr_event = \"2023-02-21 03:37:21+01:00\"\n\ndt_event = dt.datetime.strptime(str_event, \"%Y-%m-%d %H:%M:%S%z\")\nprint(f\"datetime +01:00: {dt_event.isoformat()}\")\n\nnaive datetime:  2023-02-21T02:37:21\nGTM datetime:    2023-02-21T02:37:21\ndatetime +00:00: 2023-02-21T02:37:21+00:00\ndatetime +01:00: 2023-02-21T03:37:21+01:00\n\n\nThe code above should be enough to convince you that when the offset is not specified, then we can assume the datetime is at GMT, as it was at GMT when we passed as a string.\n\n\nTimezones as capital cities\nBelow, with dateutil we can also pass the offset with the capital city based offset, such as “Asia/Tehran”.\n\nfrom dateutil import tz\n\n# country/city offset\nstr_event = \"2023-02-21 03:37:21\"\nstr_offset = \"Asia/Tehran\"\n\ndt_event = dt.datetime.strptime(str_event, \"%Y-%m-%d %H:%M:%S\")\nprint(f\"datetime: {dt_event.isoformat()}\")\ndt_event = dt_event.astimezone(tz.gettz(str_offset))\nprint(f\"datetime: {dt_event.isoformat()}\")\n\ndatetime: 2023-02-21T03:37:21\ndatetime: 2023-02-21T07:07:21+03:30\n\n\nIf you use this solution be aware that there is no validation, and if the string is misspelled or non existing, the datetime will be assigned the default +00:00 offset.\n\ndt_event = dt.datetime.strptime(str_event, \"%Y-%m-%d %H:%M:%S\")\nprint(f\"datetime: {dt_event.isoformat()}\")\n\ncorrect = \"Asia/Tehran\"\ndt_event = dt_event.astimezone(tz.gettz(correct))\nprint(f\"datetime in {correct}: {dt_event.isoformat()}\")\n\nmisspelled = \"Asia/Theran\"\ndt_event = dt_event.astimezone(tz.gettz(misspelled))\nprint(f\"datetime in {misspelled}: {dt_event.isoformat()}\")\n\nplain_wrong = \"MiddleEarth/County\"\ndt_event = dt_event.astimezone(tz.gettz(plain_wrong))\nprint(f\"datetime in {plain_wrong}: {dt_event.isoformat()}\")\n\ndatetime: 2023-02-21T03:37:21\ndatetime in Asia/Tehran: 2023-02-21T07:07:21+03:30\ndatetime in Asia/Theran: 2023-02-21T03:37:21+00:00\ndatetime in MiddleEarth/County: 2023-02-21T03:37:21+00:00\n\n\nNot raising an error for non existing capitals is not ideal. So rather than assigning the timezone dateutil I would recommend the method timezone from pytz.\n\nfrom pytz import timezone\n\ndt_event = dt.datetime.strptime(str_event, \"%Y-%m-%d %H:%M:%S\")\n\ncorrect = \"Asia/Tehran\"\ndt_event = dt_event.astimezone(tz.gettz(correct))\nprint(f\"datetime in {correct}: {dt_event.isoformat()}\")\n\nplain_wrong = \"MiddleEarth/County\"\ntry:\n    dt_event.astimezone(timezone(plain_wrong))\n    print(f\"datetime in {plain_wrong}: {dt_event.isoformat()}\")\nexcept Exception as err:\n    print(f\"Error raised: {type(err)} {err}\")\n\ndatetime in Asia/Tehran: 2023-02-21T07:07:21+03:30\nError raised: &lt;class 'pytz.exceptions.UnknownTimeZoneError'&gt; 'MiddleEarth/County'\n\n\n\n\nTimezones in pandas\nAlso to the pd.Timestamp object can be assigned a timezone with tz_localize and can be converted from one timezone to another with tz_convert (this last works only with the non-naive timestamps).\n\nindex_events = pd.date_range(start='3/1/2022', end='3/10/2022')\n\n\ntry:\n    index_events.tz_convert('US/Pacific')\nexcept TypeError as err:\n    print(f\"We can not use tz_convert directly. Error raised: {err}\")\n\nWe can not use tz_convert directly. Error raised: Cannot convert tz-naive timestamps, use tz_localize to localize\n\n\n\nindex_events_localised = index_events.tz_localize('US/Pacific')\nprint_events(index_events_localised)  # note that the datetimes are not shifted! They are considered in local time at the specified location\n\n10 days: \n[\n    2022-03-01 00:00:00-08:00\n    2022-03-02 00:00:00-08:00\n    2022-03-03 00:00:00-08:00\n    2022-03-04 00:00:00-08:00\n    2022-03-05 00:00:00-08:00\n    2022-03-06 00:00:00-08:00\n    2022-03-07 00:00:00-08:00\n    2022-03-08 00:00:00-08:00\n    2022-03-09 00:00:00-08:00\n    2022-03-10 00:00:00-08:00\n]\nThis is a &lt;class 'pandas.core.indexes.datetimes.DatetimeIndex'&gt; of &lt;class 'pandas._libs.tslibs.timestamps.Timestamp'&gt; elements.\n\n\n\nprint_events(index_events_localised.tz_convert('GMT'))\n\n10 days: \n[\n    2022-03-01 08:00:00+00:00\n    2022-03-02 08:00:00+00:00\n    2022-03-03 08:00:00+00:00\n    2022-03-04 08:00:00+00:00\n    2022-03-05 08:00:00+00:00\n    2022-03-06 08:00:00+00:00\n    2022-03-07 08:00:00+00:00\n    2022-03-08 08:00:00+00:00\n    2022-03-09 08:00:00+00:00\n    2022-03-10 08:00:00+00:00\n]\nThis is a &lt;class 'pandas.core.indexes.datetimes.DatetimeIndex'&gt; of &lt;class 'pandas._libs.tslibs.timestamps.Timestamp'&gt; elements.\n\n\nFor a given dataset of datetime in GMT, we have first to localise them over Greenwich, and then convert to the local timezone.\n\nindex_events = pd.date_range(start='3/1/2022', end='3/10/2022').tz_localize(\"GMT\")\nprint_events(index_events.tz_convert('US/Pacific'))\n\n10 days: \n[\n    2022-02-28 16:00:00-08:00\n    2022-03-01 16:00:00-08:00\n    2022-03-02 16:00:00-08:00\n    2022-03-03 16:00:00-08:00\n    2022-03-04 16:00:00-08:00\n    2022-03-05 16:00:00-08:00\n    2022-03-06 16:00:00-08:00\n    2022-03-07 16:00:00-08:00\n    2022-03-08 16:00:00-08:00\n    2022-03-09 16:00:00-08:00\n]\nThis is a &lt;class 'pandas.core.indexes.datetimes.DatetimeIndex'&gt; of &lt;class 'pandas._libs.tslibs.timestamps.Timestamp'&gt; elements."
  },
  {
    "objectID": "posts/gds-2024-01-24-timestamp/index.html#footnotes",
    "href": "posts/gds-2024-01-24-timestamp/index.html#footnotes",
    "title": "Python datetimes manipulations",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIn Python &gt;3 the concepts of class and type was unified, and pure type objects are now only the native ones.↩︎"
  }
]